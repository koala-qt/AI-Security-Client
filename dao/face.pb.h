// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: face.proto

#ifndef PROTOBUF_INCLUDED_face_2eproto
#define PROTOBUF_INCLUDED_face_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_face_2eproto 

namespace protobuf_face_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[21];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_face_2eproto
namespace kf {
class ABDoorAlarm;
class ABDoorAlarmDefaultTypeInternal;
extern ABDoorAlarmDefaultTypeInternal _ABDoorAlarm_default_instance_;
class BlackListFaceAlarm;
class BlackListFaceAlarmDefaultTypeInternal;
extern BlackListFaceAlarmDefaultTypeInternal _BlackListFaceAlarm_default_instance_;
class Box;
class BoxDefaultTypeInternal;
extern BoxDefaultTypeInternal _Box_default_instance_;
class ClimbAlarm;
class ClimbAlarmDefaultTypeInternal;
extern ClimbAlarmDefaultTypeInternal _ClimbAlarm_default_instance_;
class EventSpiderGiagram;
class EventSpiderGiagramDefaultTypeInternal;
extern EventSpiderGiagramDefaultTypeInternal _EventSpiderGiagram_default_instance_;
class FaceInfoPT;
class FaceInfoPTDefaultTypeInternal;
extern FaceInfoPTDefaultTypeInternal _FaceInfoPT_default_instance_;
class FaceStatis;
class FaceStatisDefaultTypeInternal;
extern FaceStatisDefaultTypeInternal _FaceStatis_default_instance_;
class GatherAlarm;
class GatherAlarmDefaultTypeInternal;
extern GatherAlarmDefaultTypeInternal _GatherAlarm_default_instance_;
class Intruder;
class IntruderDefaultTypeInternal;
extern IntruderDefaultTypeInternal _Intruder_default_instance_;
class LingerAlarm;
class LingerAlarmDefaultTypeInternal;
extern LingerAlarmDefaultTypeInternal _LingerAlarm_default_instance_;
class OneDayEventCount;
class OneDayEventCountDefaultTypeInternal;
extern OneDayEventCountDefaultTypeInternal _OneDayEventCount_default_instance_;
class PersonBoxs;
class PersonBoxsDefaultTypeInternal;
extern PersonBoxsDefaultTypeInternal _PersonBoxs_default_instance_;
class PieCharData;
class PieCharDataDefaultTypeInternal;
extern PieCharDataDefaultTypeInternal _PieCharData_default_instance_;
class PieChart;
class PieChartDefaultTypeInternal;
extern PieChartDefaultTypeInternal _PieChart_default_instance_;
class SnapAreaGiagram;
class SnapAreaGiagramDefaultTypeInternal;
extern SnapAreaGiagramDefaultTypeInternal _SnapAreaGiagram_default_instance_;
class StopAlarm;
class StopAlarmDefaultTypeInternal;
extern StopAlarmDefaultTypeInternal _StopAlarm_default_instance_;
class TodayAlarmEventCount;
class TodayAlarmEventCountDefaultTypeInternal;
extern TodayAlarmEventCountDefaultTypeInternal _TodayAlarmEventCount_default_instance_;
class TodayFaceCount;
class TodayFaceCountDefaultTypeInternal;
extern TodayFaceCountDefaultTypeInternal _TodayFaceCount_default_instance_;
class TodayTotalEventCount;
class TodayTotalEventCountDefaultTypeInternal;
extern TodayTotalEventCountDefaultTypeInternal _TodayTotalEventCount_default_instance_;
class TrackedFace;
class TrackedFaceDefaultTypeInternal;
extern TrackedFaceDefaultTypeInternal _TrackedFace_default_instance_;
class Tree;
class TreeDefaultTypeInternal;
extern TreeDefaultTypeInternal _Tree_default_instance_;
}  // namespace kf
namespace google {
namespace protobuf {
template<> ::kf::ABDoorAlarm* Arena::CreateMaybeMessage<::kf::ABDoorAlarm>(Arena*);
template<> ::kf::BlackListFaceAlarm* Arena::CreateMaybeMessage<::kf::BlackListFaceAlarm>(Arena*);
template<> ::kf::Box* Arena::CreateMaybeMessage<::kf::Box>(Arena*);
template<> ::kf::ClimbAlarm* Arena::CreateMaybeMessage<::kf::ClimbAlarm>(Arena*);
template<> ::kf::EventSpiderGiagram* Arena::CreateMaybeMessage<::kf::EventSpiderGiagram>(Arena*);
template<> ::kf::FaceInfoPT* Arena::CreateMaybeMessage<::kf::FaceInfoPT>(Arena*);
template<> ::kf::FaceStatis* Arena::CreateMaybeMessage<::kf::FaceStatis>(Arena*);
template<> ::kf::GatherAlarm* Arena::CreateMaybeMessage<::kf::GatherAlarm>(Arena*);
template<> ::kf::Intruder* Arena::CreateMaybeMessage<::kf::Intruder>(Arena*);
template<> ::kf::LingerAlarm* Arena::CreateMaybeMessage<::kf::LingerAlarm>(Arena*);
template<> ::kf::OneDayEventCount* Arena::CreateMaybeMessage<::kf::OneDayEventCount>(Arena*);
template<> ::kf::PersonBoxs* Arena::CreateMaybeMessage<::kf::PersonBoxs>(Arena*);
template<> ::kf::PieCharData* Arena::CreateMaybeMessage<::kf::PieCharData>(Arena*);
template<> ::kf::PieChart* Arena::CreateMaybeMessage<::kf::PieChart>(Arena*);
template<> ::kf::SnapAreaGiagram* Arena::CreateMaybeMessage<::kf::SnapAreaGiagram>(Arena*);
template<> ::kf::StopAlarm* Arena::CreateMaybeMessage<::kf::StopAlarm>(Arena*);
template<> ::kf::TodayAlarmEventCount* Arena::CreateMaybeMessage<::kf::TodayAlarmEventCount>(Arena*);
template<> ::kf::TodayFaceCount* Arena::CreateMaybeMessage<::kf::TodayFaceCount>(Arena*);
template<> ::kf::TodayTotalEventCount* Arena::CreateMaybeMessage<::kf::TodayTotalEventCount>(Arena*);
template<> ::kf::TrackedFace* Arena::CreateMaybeMessage<::kf::TrackedFace>(Arena*);
template<> ::kf::Tree* Arena::CreateMaybeMessage<::kf::Tree>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace kf {

// ===================================================================

class Box : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.Box) */ {
 public:
  Box();
  virtual ~Box();

  Box(const Box& from);

  inline Box& operator=(const Box& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Box(Box&& from) noexcept
    : Box() {
    *this = ::std::move(from);
  }

  inline Box& operator=(Box&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Box& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box* internal_default_instance() {
    return reinterpret_cast<const Box*>(
               &_Box_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Box* other);
  friend void swap(Box& a, Box& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Box* New() const final {
    return CreateMaybeMessage<Box>(NULL);
  }

  Box* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Box>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Box& from);
  void MergeFrom(const Box& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // required int32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kf.Box)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PersonBoxs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.PersonBoxs) */ {
 public:
  PersonBoxs();
  virtual ~PersonBoxs();

  PersonBoxs(const PersonBoxs& from);

  inline PersonBoxs& operator=(const PersonBoxs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PersonBoxs(PersonBoxs&& from) noexcept
    : PersonBoxs() {
    *this = ::std::move(from);
  }

  inline PersonBoxs& operator=(PersonBoxs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PersonBoxs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PersonBoxs* internal_default_instance() {
    return reinterpret_cast<const PersonBoxs*>(
               &_PersonBoxs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PersonBoxs* other);
  friend void swap(PersonBoxs& a, PersonBoxs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PersonBoxs* New() const final {
    return CreateMaybeMessage<PersonBoxs>(NULL);
  }

  PersonBoxs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PersonBoxs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PersonBoxs& from);
  void MergeFrom(const PersonBoxs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PersonBoxs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kf.Box boxes = 2;
  int boxes_size() const;
  void clear_boxes();
  static const int kBoxesFieldNumber = 2;
  ::kf::Box* mutable_boxes(int index);
  ::google::protobuf::RepeatedPtrField< ::kf::Box >*
      mutable_boxes();
  const ::kf::Box& boxes(int index) const;
  ::kf::Box* add_boxes();
  const ::google::protobuf::RepeatedPtrField< ::kf::Box >&
      boxes() const;

  // required string camera_id = 1;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // @@protoc_insertion_point(class_scope:kf.PersonBoxs)
 private:
  void set_has_camera_id();
  void clear_has_camera_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kf::Box > boxes_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceInfoPT : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.FaceInfoPT) */ {
 public:
  FaceInfoPT();
  virtual ~FaceInfoPT();

  FaceInfoPT(const FaceInfoPT& from);

  inline FaceInfoPT& operator=(const FaceInfoPT& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceInfoPT(FaceInfoPT&& from) noexcept
    : FaceInfoPT() {
    *this = ::std::move(from);
  }

  inline FaceInfoPT& operator=(FaceInfoPT&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceInfoPT& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceInfoPT* internal_default_instance() {
    return reinterpret_cast<const FaceInfoPT*>(
               &_FaceInfoPT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FaceInfoPT* other);
  friend void swap(FaceInfoPT& a, FaceInfoPT& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceInfoPT* New() const final {
    return CreateMaybeMessage<FaceInfoPT>(NULL);
  }

  FaceInfoPT* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceInfoPT>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceInfoPT& from);
  void MergeFrom(const FaceInfoPT& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceInfoPT* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string camera_id = 2;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 2;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // required string camera_pos = 3;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 3;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required bytes img_data = 4;
  bool has_img_data() const;
  void clear_img_data();
  static const int kImgDataFieldNumber = 4;
  const ::std::string& img_data() const;
  void set_img_data(const ::std::string& value);
  #if LANG_CXX11
  void set_img_data(::std::string&& value);
  #endif
  void set_img_data(const char* value);
  void set_img_data(const void* value, size_t size);
  ::std::string* mutable_img_data();
  ::std::string* release_img_data();
  void set_allocated_img_data(::std::string* img_data);

  // required string scene_id = 5;
  bool has_scene_id() const;
  void clear_scene_id();
  static const int kSceneIdFieldNumber = 5;
  const ::std::string& scene_id() const;
  void set_scene_id(const ::std::string& value);
  #if LANG_CXX11
  void set_scene_id(::std::string&& value);
  #endif
  void set_scene_id(const char* value);
  void set_scene_id(const char* value, size_t size);
  ::std::string* mutable_scene_id();
  ::std::string* release_scene_id();
  void set_allocated_scene_id(::std::string* scene_id);

  // required int64 timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kf.FaceInfoPT)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_img_data();
  void clear_has_img_data();
  void set_has_scene_id();
  void clear_has_scene_id();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::internal::ArenaStringPtr img_data_;
  ::google::protobuf::internal::ArenaStringPtr scene_id_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceStatis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.FaceStatis) */ {
 public:
  FaceStatis();
  virtual ~FaceStatis();

  FaceStatis(const FaceStatis& from);

  inline FaceStatis& operator=(const FaceStatis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaceStatis(FaceStatis&& from) noexcept
    : FaceStatis() {
    *this = ::std::move(from);
  }

  inline FaceStatis& operator=(FaceStatis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceStatis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FaceStatis* internal_default_instance() {
    return reinterpret_cast<const FaceStatis*>(
               &_FaceStatis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FaceStatis* other);
  friend void swap(FaceStatis& a, FaceStatis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaceStatis* New() const final {
    return CreateMaybeMessage<FaceStatis>(NULL);
  }

  FaceStatis* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FaceStatis>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FaceStatis& from);
  void MergeFrom(const FaceStatis& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FaceStatis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .kf.FaceInfoPT before_face = 1;
  bool has_before_face() const;
  void clear_before_face();
  static const int kBeforeFaceFieldNumber = 1;
  private:
  const ::kf::FaceInfoPT& _internal_before_face() const;
  public:
  const ::kf::FaceInfoPT& before_face() const;
  ::kf::FaceInfoPT* release_before_face();
  ::kf::FaceInfoPT* mutable_before_face();
  void set_allocated_before_face(::kf::FaceInfoPT* before_face);

  // required .kf.FaceInfoPT after_face = 2;
  bool has_after_face() const;
  void clear_after_face();
  static const int kAfterFaceFieldNumber = 2;
  private:
  const ::kf::FaceInfoPT& _internal_after_face() const;
  public:
  const ::kf::FaceInfoPT& after_face() const;
  ::kf::FaceInfoPT* release_after_face();
  ::kf::FaceInfoPT* mutable_after_face();
  void set_allocated_after_face(::kf::FaceInfoPT* after_face);

  // required int32 time_cost = 3;
  bool has_time_cost() const;
  void clear_time_cost();
  static const int kTimeCostFieldNumber = 3;
  ::google::protobuf::int32 time_cost() const;
  void set_time_cost(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kf.FaceStatis)
 private:
  void set_has_before_face();
  void clear_has_before_face();
  void set_has_after_face();
  void clear_has_after_face();
  void set_has_time_cost();
  void clear_has_time_cost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::kf::FaceInfoPT* before_face_;
  ::kf::FaceInfoPT* after_face_;
  ::google::protobuf::int32 time_cost_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrackedFace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.TrackedFace) */ {
 public:
  TrackedFace();
  virtual ~TrackedFace();

  TrackedFace(const TrackedFace& from);

  inline TrackedFace& operator=(const TrackedFace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrackedFace(TrackedFace&& from) noexcept
    : TrackedFace() {
    *this = ::std::move(from);
  }

  inline TrackedFace& operator=(TrackedFace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackedFace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrackedFace* internal_default_instance() {
    return reinterpret_cast<const TrackedFace*>(
               &_TrackedFace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TrackedFace* other);
  friend void swap(TrackedFace& a, TrackedFace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrackedFace* New() const final {
    return CreateMaybeMessage<TrackedFace>(NULL);
  }

  TrackedFace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrackedFace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrackedFace& from);
  void MergeFrom(const TrackedFace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackedFace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tracked_id = 2;
  bool has_tracked_id() const;
  void clear_tracked_id();
  static const int kTrackedIdFieldNumber = 2;
  const ::std::string& tracked_id() const;
  void set_tracked_id(const ::std::string& value);
  #if LANG_CXX11
  void set_tracked_id(::std::string&& value);
  #endif
  void set_tracked_id(const char* value);
  void set_tracked_id(const char* value, size_t size);
  ::std::string* mutable_tracked_id();
  ::std::string* release_tracked_id();
  void set_allocated_tracked_id(::std::string* tracked_id);

  // required .kf.FaceInfoPT face_info = 1;
  bool has_face_info() const;
  void clear_face_info();
  static const int kFaceInfoFieldNumber = 1;
  private:
  const ::kf::FaceInfoPT& _internal_face_info() const;
  public:
  const ::kf::FaceInfoPT& face_info() const;
  ::kf::FaceInfoPT* release_face_info();
  ::kf::FaceInfoPT* mutable_face_info();
  void set_allocated_face_info(::kf::FaceInfoPT* face_info);

  // @@protoc_insertion_point(class_scope:kf.TrackedFace)
 private:
  void set_has_face_info();
  void clear_has_face_info();
  void set_has_tracked_id();
  void clear_has_tracked_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tracked_id_;
  ::kf::FaceInfoPT* face_info_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlackListFaceAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.BlackListFaceAlarm) */ {
 public:
  BlackListFaceAlarm();
  virtual ~BlackListFaceAlarm();

  BlackListFaceAlarm(const BlackListFaceAlarm& from);

  inline BlackListFaceAlarm& operator=(const BlackListFaceAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlackListFaceAlarm(BlackListFaceAlarm&& from) noexcept
    : BlackListFaceAlarm() {
    *this = ::std::move(from);
  }

  inline BlackListFaceAlarm& operator=(BlackListFaceAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackListFaceAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlackListFaceAlarm* internal_default_instance() {
    return reinterpret_cast<const BlackListFaceAlarm*>(
               &_BlackListFaceAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BlackListFaceAlarm* other);
  friend void swap(BlackListFaceAlarm& a, BlackListFaceAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlackListFaceAlarm* New() const final {
    return CreateMaybeMessage<BlackListFaceAlarm>(NULL);
  }

  BlackListFaceAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlackListFaceAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlackListFaceAlarm& from);
  void MergeFrom(const BlackListFaceAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlackListFaceAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string oid = 1;
  bool has_oid() const;
  void clear_oid();
  static const int kOidFieldNumber = 1;
  const ::std::string& oid() const;
  void set_oid(const ::std::string& value);
  #if LANG_CXX11
  void set_oid(::std::string&& value);
  #endif
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  ::std::string* mutable_oid();
  ::std::string* release_oid();
  void set_allocated_oid(::std::string* oid);

  // required string camera_id = 2;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 2;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // required string camera_pos = 3;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 3;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required bytes face_img = 4;
  bool has_face_img() const;
  void clear_face_img();
  static const int kFaceImgFieldNumber = 4;
  const ::std::string& face_img() const;
  void set_face_img(const ::std::string& value);
  #if LANG_CXX11
  void set_face_img(::std::string&& value);
  #endif
  void set_face_img(const char* value);
  void set_face_img(const void* value, size_t size);
  ::std::string* mutable_face_img();
  ::std::string* release_face_img();
  void set_allocated_face_img(::std::string* face_img);

  // required bytes thumbnail_scene = 5;
  bool has_thumbnail_scene() const;
  void clear_thumbnail_scene();
  static const int kThumbnailSceneFieldNumber = 5;
  const ::std::string& thumbnail_scene() const;
  void set_thumbnail_scene(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_scene(::std::string&& value);
  #endif
  void set_thumbnail_scene(const char* value);
  void set_thumbnail_scene(const void* value, size_t size);
  ::std::string* mutable_thumbnail_scene();
  ::std::string* release_thumbnail_scene();
  void set_allocated_thumbnail_scene(::std::string* thumbnail_scene);

  // required int64 timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kf.BlackListFaceAlarm)
 private:
  void set_has_oid();
  void clear_has_oid();
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_face_img();
  void clear_has_face_img();
  void set_has_thumbnail_scene();
  void clear_has_thumbnail_scene();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr oid_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::internal::ArenaStringPtr face_img_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_scene_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Intruder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.Intruder) */ {
 public:
  Intruder();
  virtual ~Intruder();

  Intruder(const Intruder& from);

  inline Intruder& operator=(const Intruder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Intruder(Intruder&& from) noexcept
    : Intruder() {
    *this = ::std::move(from);
  }

  inline Intruder& operator=(Intruder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Intruder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Intruder* internal_default_instance() {
    return reinterpret_cast<const Intruder*>(
               &_Intruder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Intruder* other);
  friend void swap(Intruder& a, Intruder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Intruder* New() const final {
    return CreateMaybeMessage<Intruder>(NULL);
  }

  Intruder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Intruder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Intruder& from);
  void MergeFrom(const Intruder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Intruder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes pseron_imgs = 4;
  int pseron_imgs_size() const;
  void clear_pseron_imgs();
  static const int kPseronImgsFieldNumber = 4;
  const ::std::string& pseron_imgs(int index) const;
  ::std::string* mutable_pseron_imgs(int index);
  void set_pseron_imgs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_pseron_imgs(int index, ::std::string&& value);
  #endif
  void set_pseron_imgs(int index, const char* value);
  void set_pseron_imgs(int index, const void* value, size_t size);
  ::std::string* add_pseron_imgs();
  void add_pseron_imgs(const ::std::string& value);
  #if LANG_CXX11
  void add_pseron_imgs(::std::string&& value);
  #endif
  void add_pseron_imgs(const char* value);
  void add_pseron_imgs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& pseron_imgs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pseron_imgs();

  // required string oid = 1;
  bool has_oid() const;
  void clear_oid();
  static const int kOidFieldNumber = 1;
  const ::std::string& oid() const;
  void set_oid(const ::std::string& value);
  #if LANG_CXX11
  void set_oid(::std::string&& value);
  #endif
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  ::std::string* mutable_oid();
  ::std::string* release_oid();
  void set_allocated_oid(::std::string* oid);

  // required string camera_id = 2;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 2;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // required string camera_pos = 3;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 3;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required bytes thumbnail_scene = 5;
  bool has_thumbnail_scene() const;
  void clear_thumbnail_scene();
  static const int kThumbnailSceneFieldNumber = 5;
  const ::std::string& thumbnail_scene() const;
  void set_thumbnail_scene(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_scene(::std::string&& value);
  #endif
  void set_thumbnail_scene(const char* value);
  void set_thumbnail_scene(const void* value, size_t size);
  ::std::string* mutable_thumbnail_scene();
  ::std::string* release_thumbnail_scene();
  void set_allocated_thumbnail_scene(::std::string* thumbnail_scene);

  // required int64 timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kf.Intruder)
 private:
  void set_has_oid();
  void clear_has_oid();
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_thumbnail_scene();
  void clear_has_thumbnail_scene();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pseron_imgs_;
  ::google::protobuf::internal::ArenaStringPtr oid_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_scene_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ABDoorAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.ABDoorAlarm) */ {
 public:
  ABDoorAlarm();
  virtual ~ABDoorAlarm();

  ABDoorAlarm(const ABDoorAlarm& from);

  inline ABDoorAlarm& operator=(const ABDoorAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ABDoorAlarm(ABDoorAlarm&& from) noexcept
    : ABDoorAlarm() {
    *this = ::std::move(from);
  }

  inline ABDoorAlarm& operator=(ABDoorAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ABDoorAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ABDoorAlarm* internal_default_instance() {
    return reinterpret_cast<const ABDoorAlarm*>(
               &_ABDoorAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ABDoorAlarm* other);
  friend void swap(ABDoorAlarm& a, ABDoorAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ABDoorAlarm* New() const final {
    return CreateMaybeMessage<ABDoorAlarm>(NULL);
  }

  ABDoorAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ABDoorAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ABDoorAlarm& from);
  void MergeFrom(const ABDoorAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ABDoorAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string oid = 1;
  bool has_oid() const;
  void clear_oid();
  static const int kOidFieldNumber = 1;
  const ::std::string& oid() const;
  void set_oid(const ::std::string& value);
  #if LANG_CXX11
  void set_oid(::std::string&& value);
  #endif
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  ::std::string* mutable_oid();
  ::std::string* release_oid();
  void set_allocated_oid(::std::string* oid);

  // required string camera_id = 2;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 2;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // required string camera_pos = 3;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 3;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required bytes pseron_img = 4;
  bool has_pseron_img() const;
  void clear_pseron_img();
  static const int kPseronImgFieldNumber = 4;
  const ::std::string& pseron_img() const;
  void set_pseron_img(const ::std::string& value);
  #if LANG_CXX11
  void set_pseron_img(::std::string&& value);
  #endif
  void set_pseron_img(const char* value);
  void set_pseron_img(const void* value, size_t size);
  ::std::string* mutable_pseron_img();
  ::std::string* release_pseron_img();
  void set_allocated_pseron_img(::std::string* pseron_img);

  // required bytes thumbnail_scene = 5;
  bool has_thumbnail_scene() const;
  void clear_thumbnail_scene();
  static const int kThumbnailSceneFieldNumber = 5;
  const ::std::string& thumbnail_scene() const;
  void set_thumbnail_scene(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_scene(::std::string&& value);
  #endif
  void set_thumbnail_scene(const char* value);
  void set_thumbnail_scene(const void* value, size_t size);
  ::std::string* mutable_thumbnail_scene();
  ::std::string* release_thumbnail_scene();
  void set_allocated_thumbnail_scene(::std::string* thumbnail_scene);

  // required int64 timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kf.ABDoorAlarm)
 private:
  void set_has_oid();
  void clear_has_oid();
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_pseron_img();
  void clear_has_pseron_img();
  void set_has_thumbnail_scene();
  void clear_has_thumbnail_scene();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr oid_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::internal::ArenaStringPtr pseron_img_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_scene_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.StopAlarm) */ {
 public:
  StopAlarm();
  virtual ~StopAlarm();

  StopAlarm(const StopAlarm& from);

  inline StopAlarm& operator=(const StopAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopAlarm(StopAlarm&& from) noexcept
    : StopAlarm() {
    *this = ::std::move(from);
  }

  inline StopAlarm& operator=(StopAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopAlarm* internal_default_instance() {
    return reinterpret_cast<const StopAlarm*>(
               &_StopAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(StopAlarm* other);
  friend void swap(StopAlarm& a, StopAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopAlarm* New() const final {
    return CreateMaybeMessage<StopAlarm>(NULL);
  }

  StopAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StopAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StopAlarm& from);
  void MergeFrom(const StopAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes person_imgs = 3;
  int person_imgs_size() const;
  void clear_person_imgs();
  static const int kPersonImgsFieldNumber = 3;
  const ::std::string& person_imgs(int index) const;
  ::std::string* mutable_person_imgs(int index);
  void set_person_imgs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_person_imgs(int index, ::std::string&& value);
  #endif
  void set_person_imgs(int index, const char* value);
  void set_person_imgs(int index, const void* value, size_t size);
  ::std::string* add_person_imgs();
  void add_person_imgs(const ::std::string& value);
  #if LANG_CXX11
  void add_person_imgs(::std::string&& value);
  #endif
  void add_person_imgs(const char* value);
  void add_person_imgs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& person_imgs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_person_imgs();

  // required string camera_id = 1;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // required string camera_pos = 2;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 2;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required bytes thumbnail_scene = 4;
  bool has_thumbnail_scene() const;
  void clear_thumbnail_scene();
  static const int kThumbnailSceneFieldNumber = 4;
  const ::std::string& thumbnail_scene() const;
  void set_thumbnail_scene(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_scene(::std::string&& value);
  #endif
  void set_thumbnail_scene(const char* value);
  void set_thumbnail_scene(const void* value, size_t size);
  ::std::string* mutable_thumbnail_scene();
  ::std::string* release_thumbnail_scene();
  void set_allocated_thumbnail_scene(::std::string* thumbnail_scene);

  // required int64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kf.StopAlarm)
 private:
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_thumbnail_scene();
  void clear_has_thumbnail_scene();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> person_imgs_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_scene_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClimbAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.ClimbAlarm) */ {
 public:
  ClimbAlarm();
  virtual ~ClimbAlarm();

  ClimbAlarm(const ClimbAlarm& from);

  inline ClimbAlarm& operator=(const ClimbAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClimbAlarm(ClimbAlarm&& from) noexcept
    : ClimbAlarm() {
    *this = ::std::move(from);
  }

  inline ClimbAlarm& operator=(ClimbAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClimbAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClimbAlarm* internal_default_instance() {
    return reinterpret_cast<const ClimbAlarm*>(
               &_ClimbAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ClimbAlarm* other);
  friend void swap(ClimbAlarm& a, ClimbAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClimbAlarm* New() const final {
    return CreateMaybeMessage<ClimbAlarm>(NULL);
  }

  ClimbAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClimbAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClimbAlarm& from);
  void MergeFrom(const ClimbAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClimbAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes person_imgs = 3;
  int person_imgs_size() const;
  void clear_person_imgs();
  static const int kPersonImgsFieldNumber = 3;
  const ::std::string& person_imgs(int index) const;
  ::std::string* mutable_person_imgs(int index);
  void set_person_imgs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_person_imgs(int index, ::std::string&& value);
  #endif
  void set_person_imgs(int index, const char* value);
  void set_person_imgs(int index, const void* value, size_t size);
  ::std::string* add_person_imgs();
  void add_person_imgs(const ::std::string& value);
  #if LANG_CXX11
  void add_person_imgs(::std::string&& value);
  #endif
  void add_person_imgs(const char* value);
  void add_person_imgs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& person_imgs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_person_imgs();

  // required string camera_id = 1;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // required string camera_pos = 2;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 2;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required bytes thumbnail_scene = 4;
  bool has_thumbnail_scene() const;
  void clear_thumbnail_scene();
  static const int kThumbnailSceneFieldNumber = 4;
  const ::std::string& thumbnail_scene() const;
  void set_thumbnail_scene(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_scene(::std::string&& value);
  #endif
  void set_thumbnail_scene(const char* value);
  void set_thumbnail_scene(const void* value, size_t size);
  ::std::string* mutable_thumbnail_scene();
  ::std::string* release_thumbnail_scene();
  void set_allocated_thumbnail_scene(::std::string* thumbnail_scene);

  // required int64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kf.ClimbAlarm)
 private:
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_thumbnail_scene();
  void clear_has_thumbnail_scene();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> person_imgs_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_scene_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LingerAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.LingerAlarm) */ {
 public:
  LingerAlarm();
  virtual ~LingerAlarm();

  LingerAlarm(const LingerAlarm& from);

  inline LingerAlarm& operator=(const LingerAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LingerAlarm(LingerAlarm&& from) noexcept
    : LingerAlarm() {
    *this = ::std::move(from);
  }

  inline LingerAlarm& operator=(LingerAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LingerAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LingerAlarm* internal_default_instance() {
    return reinterpret_cast<const LingerAlarm*>(
               &_LingerAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(LingerAlarm* other);
  friend void swap(LingerAlarm& a, LingerAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LingerAlarm* New() const final {
    return CreateMaybeMessage<LingerAlarm>(NULL);
  }

  LingerAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LingerAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LingerAlarm& from);
  void MergeFrom(const LingerAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LingerAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes person_imgs = 3;
  int person_imgs_size() const;
  void clear_person_imgs();
  static const int kPersonImgsFieldNumber = 3;
  const ::std::string& person_imgs(int index) const;
  ::std::string* mutable_person_imgs(int index);
  void set_person_imgs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_person_imgs(int index, ::std::string&& value);
  #endif
  void set_person_imgs(int index, const char* value);
  void set_person_imgs(int index, const void* value, size_t size);
  ::std::string* add_person_imgs();
  void add_person_imgs(const ::std::string& value);
  #if LANG_CXX11
  void add_person_imgs(::std::string&& value);
  #endif
  void add_person_imgs(const char* value);
  void add_person_imgs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& person_imgs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_person_imgs();

  // required string camera_id = 1;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // required string camera_pos = 2;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 2;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required bytes thumbnail_scene = 4;
  bool has_thumbnail_scene() const;
  void clear_thumbnail_scene();
  static const int kThumbnailSceneFieldNumber = 4;
  const ::std::string& thumbnail_scene() const;
  void set_thumbnail_scene(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_scene(::std::string&& value);
  #endif
  void set_thumbnail_scene(const char* value);
  void set_thumbnail_scene(const void* value, size_t size);
  ::std::string* mutable_thumbnail_scene();
  ::std::string* release_thumbnail_scene();
  void set_allocated_thumbnail_scene(::std::string* thumbnail_scene);

  // required int64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kf.LingerAlarm)
 private:
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_thumbnail_scene();
  void clear_has_thumbnail_scene();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> person_imgs_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_scene_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GatherAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.GatherAlarm) */ {
 public:
  GatherAlarm();
  virtual ~GatherAlarm();

  GatherAlarm(const GatherAlarm& from);

  inline GatherAlarm& operator=(const GatherAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GatherAlarm(GatherAlarm&& from) noexcept
    : GatherAlarm() {
    *this = ::std::move(from);
  }

  inline GatherAlarm& operator=(GatherAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GatherAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GatherAlarm* internal_default_instance() {
    return reinterpret_cast<const GatherAlarm*>(
               &_GatherAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GatherAlarm* other);
  friend void swap(GatherAlarm& a, GatherAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GatherAlarm* New() const final {
    return CreateMaybeMessage<GatherAlarm>(NULL);
  }

  GatherAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GatherAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GatherAlarm& from);
  void MergeFrom(const GatherAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GatherAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string camera_id = 1;
  bool has_camera_id() const;
  void clear_camera_id();
  static const int kCameraIdFieldNumber = 1;
  const ::std::string& camera_id() const;
  void set_camera_id(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_id(::std::string&& value);
  #endif
  void set_camera_id(const char* value);
  void set_camera_id(const char* value, size_t size);
  ::std::string* mutable_camera_id();
  ::std::string* release_camera_id();
  void set_allocated_camera_id(::std::string* camera_id);

  // required string camera_pos = 2;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 2;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required bytes person_img = 3;
  bool has_person_img() const;
  void clear_person_img();
  static const int kPersonImgFieldNumber = 3;
  const ::std::string& person_img() const;
  void set_person_img(const ::std::string& value);
  #if LANG_CXX11
  void set_person_img(::std::string&& value);
  #endif
  void set_person_img(const char* value);
  void set_person_img(const void* value, size_t size);
  ::std::string* mutable_person_img();
  ::std::string* release_person_img();
  void set_allocated_person_img(::std::string* person_img);

  // required bytes thumbnail_scene = 4;
  bool has_thumbnail_scene() const;
  void clear_thumbnail_scene();
  static const int kThumbnailSceneFieldNumber = 4;
  const ::std::string& thumbnail_scene() const;
  void set_thumbnail_scene(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_scene(::std::string&& value);
  #endif
  void set_thumbnail_scene(const char* value);
  void set_thumbnail_scene(const void* value, size_t size);
  ::std::string* mutable_thumbnail_scene();
  ::std::string* release_thumbnail_scene();
  void set_allocated_thumbnail_scene(::std::string* thumbnail_scene);

  // required int64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kf.GatherAlarm)
 private:
  void set_has_camera_id();
  void clear_has_camera_id();
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_person_img();
  void clear_has_person_img();
  void set_has_thumbnail_scene();
  void clear_has_thumbnail_scene();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr camera_id_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::internal::ArenaStringPtr person_img_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_scene_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TodayTotalEventCount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.TodayTotalEventCount) */ {
 public:
  TodayTotalEventCount();
  virtual ~TodayTotalEventCount();

  TodayTotalEventCount(const TodayTotalEventCount& from);

  inline TodayTotalEventCount& operator=(const TodayTotalEventCount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TodayTotalEventCount(TodayTotalEventCount&& from) noexcept
    : TodayTotalEventCount() {
    *this = ::std::move(from);
  }

  inline TodayTotalEventCount& operator=(TodayTotalEventCount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TodayTotalEventCount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TodayTotalEventCount* internal_default_instance() {
    return reinterpret_cast<const TodayTotalEventCount*>(
               &_TodayTotalEventCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(TodayTotalEventCount* other);
  friend void swap(TodayTotalEventCount& a, TodayTotalEventCount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TodayTotalEventCount* New() const final {
    return CreateMaybeMessage<TodayTotalEventCount>(NULL);
  }

  TodayTotalEventCount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TodayTotalEventCount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TodayTotalEventCount& from);
  void MergeFrom(const TodayTotalEventCount& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TodayTotalEventCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 total_count = 1;
  bool has_total_count() const;
  void clear_total_count();
  static const int kTotalCountFieldNumber = 1;
  ::google::protobuf::int32 total_count() const;
  void set_total_count(::google::protobuf::int32 value);

  // required int32 blacklist_count = 2;
  bool has_blacklist_count() const;
  void clear_blacklist_count();
  static const int kBlacklistCountFieldNumber = 2;
  ::google::protobuf::int32 blacklist_count() const;
  void set_blacklist_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kf.TodayTotalEventCount)
 private:
  void set_has_total_count();
  void clear_has_total_count();
  void set_has_blacklist_count();
  void clear_has_blacklist_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 total_count_;
  ::google::protobuf::int32 blacklist_count_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OneDayEventCount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.OneDayEventCount) */ {
 public:
  OneDayEventCount();
  virtual ~OneDayEventCount();

  OneDayEventCount(const OneDayEventCount& from);

  inline OneDayEventCount& operator=(const OneDayEventCount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OneDayEventCount(OneDayEventCount&& from) noexcept
    : OneDayEventCount() {
    *this = ::std::move(from);
  }

  inline OneDayEventCount& operator=(OneDayEventCount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OneDayEventCount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OneDayEventCount* internal_default_instance() {
    return reinterpret_cast<const OneDayEventCount*>(
               &_OneDayEventCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(OneDayEventCount* other);
  friend void swap(OneDayEventCount& a, OneDayEventCount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OneDayEventCount* New() const final {
    return CreateMaybeMessage<OneDayEventCount>(NULL);
  }

  OneDayEventCount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OneDayEventCount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OneDayEventCount& from);
  void MergeFrom(const OneDayEventCount& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneDayEventCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 event_count = 1;
  int event_count_size() const;
  void clear_event_count();
  static const int kEventCountFieldNumber = 1;
  ::google::protobuf::int32 event_count(int index) const;
  void set_event_count(int index, ::google::protobuf::int32 value);
  void add_event_count(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      event_count() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_event_count();

  // @@protoc_insertion_point(class_scope:kf.OneDayEventCount)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > event_count_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EventSpiderGiagram : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.EventSpiderGiagram) */ {
 public:
  EventSpiderGiagram();
  virtual ~EventSpiderGiagram();

  EventSpiderGiagram(const EventSpiderGiagram& from);

  inline EventSpiderGiagram& operator=(const EventSpiderGiagram& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventSpiderGiagram(EventSpiderGiagram&& from) noexcept
    : EventSpiderGiagram() {
    *this = ::std::move(from);
  }

  inline EventSpiderGiagram& operator=(EventSpiderGiagram&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventSpiderGiagram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventSpiderGiagram* internal_default_instance() {
    return reinterpret_cast<const EventSpiderGiagram*>(
               &_EventSpiderGiagram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(EventSpiderGiagram* other);
  friend void swap(EventSpiderGiagram& a, EventSpiderGiagram& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventSpiderGiagram* New() const final {
    return CreateMaybeMessage<EventSpiderGiagram>(NULL);
  }

  EventSpiderGiagram* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EventSpiderGiagram>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EventSpiderGiagram& from);
  void MergeFrom(const EventSpiderGiagram& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventSpiderGiagram* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kf.OneDayEventCount someday_count = 1;
  int someday_count_size() const;
  void clear_someday_count();
  static const int kSomedayCountFieldNumber = 1;
  ::kf::OneDayEventCount* mutable_someday_count(int index);
  ::google::protobuf::RepeatedPtrField< ::kf::OneDayEventCount >*
      mutable_someday_count();
  const ::kf::OneDayEventCount& someday_count(int index) const;
  ::kf::OneDayEventCount* add_someday_count();
  const ::google::protobuf::RepeatedPtrField< ::kf::OneDayEventCount >&
      someday_count() const;

  // @@protoc_insertion_point(class_scope:kf.EventSpiderGiagram)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kf::OneDayEventCount > someday_count_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TodayAlarmEventCount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.TodayAlarmEventCount) */ {
 public:
  TodayAlarmEventCount();
  virtual ~TodayAlarmEventCount();

  TodayAlarmEventCount(const TodayAlarmEventCount& from);

  inline TodayAlarmEventCount& operator=(const TodayAlarmEventCount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TodayAlarmEventCount(TodayAlarmEventCount&& from) noexcept
    : TodayAlarmEventCount() {
    *this = ::std::move(from);
  }

  inline TodayAlarmEventCount& operator=(TodayAlarmEventCount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TodayAlarmEventCount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TodayAlarmEventCount* internal_default_instance() {
    return reinterpret_cast<const TodayAlarmEventCount*>(
               &_TodayAlarmEventCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(TodayAlarmEventCount* other);
  friend void swap(TodayAlarmEventCount& a, TodayAlarmEventCount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TodayAlarmEventCount* New() const final {
    return CreateMaybeMessage<TodayAlarmEventCount>(NULL);
  }

  TodayAlarmEventCount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TodayAlarmEventCount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TodayAlarmEventCount& from);
  void MergeFrom(const TodayAlarmEventCount& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TodayAlarmEventCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ab_count = 1;
  bool has_ab_count() const;
  void clear_ab_count();
  static const int kAbCountFieldNumber = 1;
  ::google::protobuf::int32 ab_count() const;
  void set_ab_count(::google::protobuf::int32 value);

  // required int32 intrude_count = 2;
  bool has_intrude_count() const;
  void clear_intrude_count();
  static const int kIntrudeCountFieldNumber = 2;
  ::google::protobuf::int32 intrude_count() const;
  void set_intrude_count(::google::protobuf::int32 value);

  // required int32 blacklist_count = 3;
  bool has_blacklist_count() const;
  void clear_blacklist_count();
  static const int kBlacklistCountFieldNumber = 3;
  ::google::protobuf::int32 blacklist_count() const;
  void set_blacklist_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kf.TodayAlarmEventCount)
 private:
  void set_has_ab_count();
  void clear_has_ab_count();
  void set_has_intrude_count();
  void clear_has_intrude_count();
  void set_has_blacklist_count();
  void clear_has_blacklist_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 ab_count_;
  ::google::protobuf::int32 intrude_count_;
  ::google::protobuf::int32 blacklist_count_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PieCharData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.PieCharData) */ {
 public:
  PieCharData();
  virtual ~PieCharData();

  PieCharData(const PieCharData& from);

  inline PieCharData& operator=(const PieCharData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PieCharData(PieCharData&& from) noexcept
    : PieCharData() {
    *this = ::std::move(from);
  }

  inline PieCharData& operator=(PieCharData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PieCharData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PieCharData* internal_default_instance() {
    return reinterpret_cast<const PieCharData*>(
               &_PieCharData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(PieCharData* other);
  friend void swap(PieCharData& a, PieCharData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PieCharData* New() const final {
    return CreateMaybeMessage<PieCharData>(NULL);
  }

  PieCharData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PieCharData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PieCharData& from);
  void MergeFrom(const PieCharData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PieCharData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string camera_pos = 1;
  bool has_camera_pos() const;
  void clear_camera_pos();
  static const int kCameraPosFieldNumber = 1;
  const ::std::string& camera_pos() const;
  void set_camera_pos(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_pos(::std::string&& value);
  #endif
  void set_camera_pos(const char* value);
  void set_camera_pos(const char* value, size_t size);
  ::std::string* mutable_camera_pos();
  ::std::string* release_camera_pos();
  void set_allocated_camera_pos(::std::string* camera_pos);

  // required int32 cost_time = 2;
  bool has_cost_time() const;
  void clear_cost_time();
  static const int kCostTimeFieldNumber = 2;
  ::google::protobuf::int32 cost_time() const;
  void set_cost_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kf.PieCharData)
 private:
  void set_has_camera_pos();
  void clear_has_camera_pos();
  void set_has_cost_time();
  void clear_has_cost_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr camera_pos_;
  ::google::protobuf::int32 cost_time_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PieChart : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.PieChart) */ {
 public:
  PieChart();
  virtual ~PieChart();

  PieChart(const PieChart& from);

  inline PieChart& operator=(const PieChart& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PieChart(PieChart&& from) noexcept
    : PieChart() {
    *this = ::std::move(from);
  }

  inline PieChart& operator=(PieChart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PieChart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PieChart* internal_default_instance() {
    return reinterpret_cast<const PieChart*>(
               &_PieChart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(PieChart* other);
  friend void swap(PieChart& a, PieChart& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PieChart* New() const final {
    return CreateMaybeMessage<PieChart>(NULL);
  }

  PieChart* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PieChart>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PieChart& from);
  void MergeFrom(const PieChart& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PieChart* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kf.PieCharData pie_chart_data = 1;
  int pie_chart_data_size() const;
  void clear_pie_chart_data();
  static const int kPieChartDataFieldNumber = 1;
  ::kf::PieCharData* mutable_pie_chart_data(int index);
  ::google::protobuf::RepeatedPtrField< ::kf::PieCharData >*
      mutable_pie_chart_data();
  const ::kf::PieCharData& pie_chart_data(int index) const;
  ::kf::PieCharData* add_pie_chart_data();
  const ::google::protobuf::RepeatedPtrField< ::kf::PieCharData >&
      pie_chart_data() const;

  // @@protoc_insertion_point(class_scope:kf.PieChart)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kf::PieCharData > pie_chart_data_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TodayFaceCount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.TodayFaceCount) */ {
 public:
  TodayFaceCount();
  virtual ~TodayFaceCount();

  TodayFaceCount(const TodayFaceCount& from);

  inline TodayFaceCount& operator=(const TodayFaceCount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TodayFaceCount(TodayFaceCount&& from) noexcept
    : TodayFaceCount() {
    *this = ::std::move(from);
  }

  inline TodayFaceCount& operator=(TodayFaceCount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TodayFaceCount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TodayFaceCount* internal_default_instance() {
    return reinterpret_cast<const TodayFaceCount*>(
               &_TodayFaceCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(TodayFaceCount* other);
  friend void swap(TodayFaceCount& a, TodayFaceCount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TodayFaceCount* New() const final {
    return CreateMaybeMessage<TodayFaceCount>(NULL);
  }

  TodayFaceCount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TodayFaceCount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TodayFaceCount& from);
  void MergeFrom(const TodayFaceCount& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TodayFaceCount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 snap_count = 1;
  bool has_snap_count() const;
  void clear_snap_count();
  static const int kSnapCountFieldNumber = 1;
  ::google::protobuf::int32 snap_count() const;
  void set_snap_count(::google::protobuf::int32 value);

  // required int32 blacklist_count = 2;
  bool has_blacklist_count() const;
  void clear_blacklist_count();
  static const int kBlacklistCountFieldNumber = 2;
  ::google::protobuf::int32 blacklist_count() const;
  void set_blacklist_count(::google::protobuf::int32 value);

  // required int32 served_count = 3;
  bool has_served_count() const;
  void clear_served_count();
  static const int kServedCountFieldNumber = 3;
  ::google::protobuf::int32 served_count() const;
  void set_served_count(::google::protobuf::int32 value);

  // required int32 blacklist_alarm_count = 4;
  bool has_blacklist_alarm_count() const;
  void clear_blacklist_alarm_count();
  static const int kBlacklistAlarmCountFieldNumber = 4;
  ::google::protobuf::int32 blacklist_alarm_count() const;
  void set_blacklist_alarm_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kf.TodayFaceCount)
 private:
  void set_has_snap_count();
  void clear_has_snap_count();
  void set_has_blacklist_count();
  void clear_has_blacklist_count();
  void set_has_served_count();
  void clear_has_served_count();
  void set_has_blacklist_alarm_count();
  void clear_has_blacklist_alarm_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 snap_count_;
  ::google::protobuf::int32 blacklist_count_;
  ::google::protobuf::int32 served_count_;
  ::google::protobuf::int32 blacklist_alarm_count_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SnapAreaGiagram : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.SnapAreaGiagram) */ {
 public:
  SnapAreaGiagram();
  virtual ~SnapAreaGiagram();

  SnapAreaGiagram(const SnapAreaGiagram& from);

  inline SnapAreaGiagram& operator=(const SnapAreaGiagram& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SnapAreaGiagram(SnapAreaGiagram&& from) noexcept
    : SnapAreaGiagram() {
    *this = ::std::move(from);
  }

  inline SnapAreaGiagram& operator=(SnapAreaGiagram&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnapAreaGiagram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnapAreaGiagram* internal_default_instance() {
    return reinterpret_cast<const SnapAreaGiagram*>(
               &_SnapAreaGiagram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(SnapAreaGiagram* other);
  friend void swap(SnapAreaGiagram& a, SnapAreaGiagram& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SnapAreaGiagram* New() const final {
    return CreateMaybeMessage<SnapAreaGiagram>(NULL);
  }

  SnapAreaGiagram* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SnapAreaGiagram>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SnapAreaGiagram& from);
  void MergeFrom(const SnapAreaGiagram& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapAreaGiagram* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 snap_count_point = 1;
  int snap_count_point_size() const;
  void clear_snap_count_point();
  static const int kSnapCountPointFieldNumber = 1;
  ::google::protobuf::int32 snap_count_point(int index) const;
  void set_snap_count_point(int index, ::google::protobuf::int32 value);
  void add_snap_count_point(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      snap_count_point() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_snap_count_point();

  // @@protoc_insertion_point(class_scope:kf.SnapAreaGiagram)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > snap_count_point_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tree : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kf.Tree) */ {
 public:
  Tree();
  virtual ~Tree();

  Tree(const Tree& from);

  inline Tree& operator=(const Tree& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tree(Tree&& from) noexcept
    : Tree() {
    *this = ::std::move(from);
  }

  inline Tree& operator=(Tree&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tree& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tree* internal_default_instance() {
    return reinterpret_cast<const Tree*>(
               &_Tree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Tree* other);
  friend void swap(Tree& a, Tree& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tree* New() const final {
    return CreateMaybeMessage<Tree>(NULL);
  }

  Tree* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tree>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tree& from);
  void MergeFrom(const Tree& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tree* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string oid = 2;
  bool has_oid() const;
  void clear_oid();
  static const int kOidFieldNumber = 2;
  const ::std::string& oid() const;
  void set_oid(const ::std::string& value);
  #if LANG_CXX11
  void set_oid(::std::string&& value);
  #endif
  void set_oid(const char* value);
  void set_oid(const char* value, size_t size);
  ::std::string* mutable_oid();
  ::std::string* release_oid();
  void set_allocated_oid(::std::string* oid);

  // required string msg = 3;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 3;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // required int32 status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kf.Tree)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_oid();
  void clear_has_oid();
  void set_has_msg();
  void clear_has_msg();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr oid_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::int32 status_;
  friend struct ::protobuf_face_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Box

// required int32 x = 1;
inline bool Box::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Box::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Box::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Box::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Box::x() const {
  // @@protoc_insertion_point(field_get:kf.Box.x)
  return x_;
}
inline void Box::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:kf.Box.x)
}

// required int32 y = 2;
inline bool Box::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Box::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Box::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Box::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Box::y() const {
  // @@protoc_insertion_point(field_get:kf.Box.y)
  return y_;
}
inline void Box::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:kf.Box.y)
}

// required int32 width = 3;
inline bool Box::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Box::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Box::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Box::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Box::width() const {
  // @@protoc_insertion_point(field_get:kf.Box.width)
  return width_;
}
inline void Box::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:kf.Box.width)
}

// required int32 height = 4;
inline bool Box::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Box::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Box::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Box::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Box::height() const {
  // @@protoc_insertion_point(field_get:kf.Box.height)
  return height_;
}
inline void Box::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:kf.Box.height)
}

// -------------------------------------------------------------------

// PersonBoxs

// required string camera_id = 1;
inline bool PersonBoxs::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PersonBoxs::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PersonBoxs::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PersonBoxs::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& PersonBoxs::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.PersonBoxs.camera_id)
  return camera_id_.GetNoArena();
}
inline void PersonBoxs::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.PersonBoxs.camera_id)
}
#if LANG_CXX11
inline void PersonBoxs::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.PersonBoxs.camera_id)
}
#endif
inline void PersonBoxs::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.PersonBoxs.camera_id)
}
inline void PersonBoxs::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.PersonBoxs.camera_id)
}
inline ::std::string* PersonBoxs::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.PersonBoxs.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PersonBoxs::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.PersonBoxs.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PersonBoxs::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.PersonBoxs.camera_id)
}

// repeated .kf.Box boxes = 2;
inline int PersonBoxs::boxes_size() const {
  return boxes_.size();
}
inline void PersonBoxs::clear_boxes() {
  boxes_.Clear();
}
inline ::kf::Box* PersonBoxs::mutable_boxes(int index) {
  // @@protoc_insertion_point(field_mutable:kf.PersonBoxs.boxes)
  return boxes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kf::Box >*
PersonBoxs::mutable_boxes() {
  // @@protoc_insertion_point(field_mutable_list:kf.PersonBoxs.boxes)
  return &boxes_;
}
inline const ::kf::Box& PersonBoxs::boxes(int index) const {
  // @@protoc_insertion_point(field_get:kf.PersonBoxs.boxes)
  return boxes_.Get(index);
}
inline ::kf::Box* PersonBoxs::add_boxes() {
  // @@protoc_insertion_point(field_add:kf.PersonBoxs.boxes)
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kf::Box >&
PersonBoxs::boxes() const {
  // @@protoc_insertion_point(field_list:kf.PersonBoxs.boxes)
  return boxes_;
}

// -------------------------------------------------------------------

// FaceInfoPT

// required string id = 1;
inline bool FaceInfoPT::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaceInfoPT::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaceInfoPT::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaceInfoPT::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& FaceInfoPT::id() const {
  // @@protoc_insertion_point(field_get:kf.FaceInfoPT.id)
  return id_.GetNoArena();
}
inline void FaceInfoPT::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.FaceInfoPT.id)
}
#if LANG_CXX11
inline void FaceInfoPT::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.FaceInfoPT.id)
}
#endif
inline void FaceInfoPT::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.FaceInfoPT.id)
}
inline void FaceInfoPT::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.FaceInfoPT.id)
}
inline ::std::string* FaceInfoPT::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:kf.FaceInfoPT.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceInfoPT::release_id() {
  // @@protoc_insertion_point(field_release:kf.FaceInfoPT.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceInfoPT::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:kf.FaceInfoPT.id)
}

// required string camera_id = 2;
inline bool FaceInfoPT::has_camera_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaceInfoPT::set_has_camera_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaceInfoPT::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaceInfoPT::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& FaceInfoPT::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.FaceInfoPT.camera_id)
  return camera_id_.GetNoArena();
}
inline void FaceInfoPT::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.FaceInfoPT.camera_id)
}
#if LANG_CXX11
inline void FaceInfoPT::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.FaceInfoPT.camera_id)
}
#endif
inline void FaceInfoPT::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.FaceInfoPT.camera_id)
}
inline void FaceInfoPT::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.FaceInfoPT.camera_id)
}
inline ::std::string* FaceInfoPT::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.FaceInfoPT.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceInfoPT::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.FaceInfoPT.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceInfoPT::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.FaceInfoPT.camera_id)
}

// required string camera_pos = 3;
inline bool FaceInfoPT::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FaceInfoPT::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FaceInfoPT::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FaceInfoPT::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& FaceInfoPT::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.FaceInfoPT.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void FaceInfoPT::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.FaceInfoPT.camera_pos)
}
#if LANG_CXX11
inline void FaceInfoPT::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.FaceInfoPT.camera_pos)
}
#endif
inline void FaceInfoPT::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.FaceInfoPT.camera_pos)
}
inline void FaceInfoPT::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.FaceInfoPT.camera_pos)
}
inline ::std::string* FaceInfoPT::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.FaceInfoPT.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceInfoPT::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.FaceInfoPT.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceInfoPT::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.FaceInfoPT.camera_pos)
}

// required bytes img_data = 4;
inline bool FaceInfoPT::has_img_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FaceInfoPT::set_has_img_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FaceInfoPT::clear_has_img_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FaceInfoPT::clear_img_data() {
  img_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_img_data();
}
inline const ::std::string& FaceInfoPT::img_data() const {
  // @@protoc_insertion_point(field_get:kf.FaceInfoPT.img_data)
  return img_data_.GetNoArena();
}
inline void FaceInfoPT::set_img_data(const ::std::string& value) {
  set_has_img_data();
  img_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.FaceInfoPT.img_data)
}
#if LANG_CXX11
inline void FaceInfoPT::set_img_data(::std::string&& value) {
  set_has_img_data();
  img_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.FaceInfoPT.img_data)
}
#endif
inline void FaceInfoPT::set_img_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_img_data();
  img_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.FaceInfoPT.img_data)
}
inline void FaceInfoPT::set_img_data(const void* value, size_t size) {
  set_has_img_data();
  img_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.FaceInfoPT.img_data)
}
inline ::std::string* FaceInfoPT::mutable_img_data() {
  set_has_img_data();
  // @@protoc_insertion_point(field_mutable:kf.FaceInfoPT.img_data)
  return img_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceInfoPT::release_img_data() {
  // @@protoc_insertion_point(field_release:kf.FaceInfoPT.img_data)
  if (!has_img_data()) {
    return NULL;
  }
  clear_has_img_data();
  return img_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceInfoPT::set_allocated_img_data(::std::string* img_data) {
  if (img_data != NULL) {
    set_has_img_data();
  } else {
    clear_has_img_data();
  }
  img_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), img_data);
  // @@protoc_insertion_point(field_set_allocated:kf.FaceInfoPT.img_data)
}

// required string scene_id = 5;
inline bool FaceInfoPT::has_scene_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FaceInfoPT::set_has_scene_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FaceInfoPT::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FaceInfoPT::clear_scene_id() {
  scene_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scene_id();
}
inline const ::std::string& FaceInfoPT::scene_id() const {
  // @@protoc_insertion_point(field_get:kf.FaceInfoPT.scene_id)
  return scene_id_.GetNoArena();
}
inline void FaceInfoPT::set_scene_id(const ::std::string& value) {
  set_has_scene_id();
  scene_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.FaceInfoPT.scene_id)
}
#if LANG_CXX11
inline void FaceInfoPT::set_scene_id(::std::string&& value) {
  set_has_scene_id();
  scene_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.FaceInfoPT.scene_id)
}
#endif
inline void FaceInfoPT::set_scene_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_scene_id();
  scene_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.FaceInfoPT.scene_id)
}
inline void FaceInfoPT::set_scene_id(const char* value, size_t size) {
  set_has_scene_id();
  scene_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.FaceInfoPT.scene_id)
}
inline ::std::string* FaceInfoPT::mutable_scene_id() {
  set_has_scene_id();
  // @@protoc_insertion_point(field_mutable:kf.FaceInfoPT.scene_id)
  return scene_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceInfoPT::release_scene_id() {
  // @@protoc_insertion_point(field_release:kf.FaceInfoPT.scene_id)
  if (!has_scene_id()) {
    return NULL;
  }
  clear_has_scene_id();
  return scene_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceInfoPT::set_allocated_scene_id(::std::string* scene_id) {
  if (scene_id != NULL) {
    set_has_scene_id();
  } else {
    clear_has_scene_id();
  }
  scene_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scene_id);
  // @@protoc_insertion_point(field_set_allocated:kf.FaceInfoPT.scene_id)
}

// required int64 timestamp = 6;
inline bool FaceInfoPT::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FaceInfoPT::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FaceInfoPT::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FaceInfoPT::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 FaceInfoPT::timestamp() const {
  // @@protoc_insertion_point(field_get:kf.FaceInfoPT.timestamp)
  return timestamp_;
}
inline void FaceInfoPT::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:kf.FaceInfoPT.timestamp)
}

// -------------------------------------------------------------------

// FaceStatis

// required .kf.FaceInfoPT before_face = 1;
inline bool FaceStatis::has_before_face() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaceStatis::set_has_before_face() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaceStatis::clear_has_before_face() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaceStatis::clear_before_face() {
  if (before_face_ != NULL) before_face_->Clear();
  clear_has_before_face();
}
inline const ::kf::FaceInfoPT& FaceStatis::_internal_before_face() const {
  return *before_face_;
}
inline const ::kf::FaceInfoPT& FaceStatis::before_face() const {
  const ::kf::FaceInfoPT* p = before_face_;
  // @@protoc_insertion_point(field_get:kf.FaceStatis.before_face)
  return p != NULL ? *p : *reinterpret_cast<const ::kf::FaceInfoPT*>(
      &::kf::_FaceInfoPT_default_instance_);
}
inline ::kf::FaceInfoPT* FaceStatis::release_before_face() {
  // @@protoc_insertion_point(field_release:kf.FaceStatis.before_face)
  clear_has_before_face();
  ::kf::FaceInfoPT* temp = before_face_;
  before_face_ = NULL;
  return temp;
}
inline ::kf::FaceInfoPT* FaceStatis::mutable_before_face() {
  set_has_before_face();
  if (before_face_ == NULL) {
    auto* p = CreateMaybeMessage<::kf::FaceInfoPT>(GetArenaNoVirtual());
    before_face_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kf.FaceStatis.before_face)
  return before_face_;
}
inline void FaceStatis::set_allocated_before_face(::kf::FaceInfoPT* before_face) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete before_face_;
  }
  if (before_face) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      before_face = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, before_face, submessage_arena);
    }
    set_has_before_face();
  } else {
    clear_has_before_face();
  }
  before_face_ = before_face;
  // @@protoc_insertion_point(field_set_allocated:kf.FaceStatis.before_face)
}

// required .kf.FaceInfoPT after_face = 2;
inline bool FaceStatis::has_after_face() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaceStatis::set_has_after_face() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaceStatis::clear_has_after_face() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaceStatis::clear_after_face() {
  if (after_face_ != NULL) after_face_->Clear();
  clear_has_after_face();
}
inline const ::kf::FaceInfoPT& FaceStatis::_internal_after_face() const {
  return *after_face_;
}
inline const ::kf::FaceInfoPT& FaceStatis::after_face() const {
  const ::kf::FaceInfoPT* p = after_face_;
  // @@protoc_insertion_point(field_get:kf.FaceStatis.after_face)
  return p != NULL ? *p : *reinterpret_cast<const ::kf::FaceInfoPT*>(
      &::kf::_FaceInfoPT_default_instance_);
}
inline ::kf::FaceInfoPT* FaceStatis::release_after_face() {
  // @@protoc_insertion_point(field_release:kf.FaceStatis.after_face)
  clear_has_after_face();
  ::kf::FaceInfoPT* temp = after_face_;
  after_face_ = NULL;
  return temp;
}
inline ::kf::FaceInfoPT* FaceStatis::mutable_after_face() {
  set_has_after_face();
  if (after_face_ == NULL) {
    auto* p = CreateMaybeMessage<::kf::FaceInfoPT>(GetArenaNoVirtual());
    after_face_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kf.FaceStatis.after_face)
  return after_face_;
}
inline void FaceStatis::set_allocated_after_face(::kf::FaceInfoPT* after_face) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete after_face_;
  }
  if (after_face) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      after_face = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, after_face, submessage_arena);
    }
    set_has_after_face();
  } else {
    clear_has_after_face();
  }
  after_face_ = after_face;
  // @@protoc_insertion_point(field_set_allocated:kf.FaceStatis.after_face)
}

// required int32 time_cost = 3;
inline bool FaceStatis::has_time_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FaceStatis::set_has_time_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FaceStatis::clear_has_time_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FaceStatis::clear_time_cost() {
  time_cost_ = 0;
  clear_has_time_cost();
}
inline ::google::protobuf::int32 FaceStatis::time_cost() const {
  // @@protoc_insertion_point(field_get:kf.FaceStatis.time_cost)
  return time_cost_;
}
inline void FaceStatis::set_time_cost(::google::protobuf::int32 value) {
  set_has_time_cost();
  time_cost_ = value;
  // @@protoc_insertion_point(field_set:kf.FaceStatis.time_cost)
}

// -------------------------------------------------------------------

// TrackedFace

// required .kf.FaceInfoPT face_info = 1;
inline bool TrackedFace::has_face_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackedFace::set_has_face_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackedFace::clear_has_face_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackedFace::clear_face_info() {
  if (face_info_ != NULL) face_info_->Clear();
  clear_has_face_info();
}
inline const ::kf::FaceInfoPT& TrackedFace::_internal_face_info() const {
  return *face_info_;
}
inline const ::kf::FaceInfoPT& TrackedFace::face_info() const {
  const ::kf::FaceInfoPT* p = face_info_;
  // @@protoc_insertion_point(field_get:kf.TrackedFace.face_info)
  return p != NULL ? *p : *reinterpret_cast<const ::kf::FaceInfoPT*>(
      &::kf::_FaceInfoPT_default_instance_);
}
inline ::kf::FaceInfoPT* TrackedFace::release_face_info() {
  // @@protoc_insertion_point(field_release:kf.TrackedFace.face_info)
  clear_has_face_info();
  ::kf::FaceInfoPT* temp = face_info_;
  face_info_ = NULL;
  return temp;
}
inline ::kf::FaceInfoPT* TrackedFace::mutable_face_info() {
  set_has_face_info();
  if (face_info_ == NULL) {
    auto* p = CreateMaybeMessage<::kf::FaceInfoPT>(GetArenaNoVirtual());
    face_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kf.TrackedFace.face_info)
  return face_info_;
}
inline void TrackedFace::set_allocated_face_info(::kf::FaceInfoPT* face_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete face_info_;
  }
  if (face_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      face_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, face_info, submessage_arena);
    }
    set_has_face_info();
  } else {
    clear_has_face_info();
  }
  face_info_ = face_info;
  // @@protoc_insertion_point(field_set_allocated:kf.TrackedFace.face_info)
}

// required string tracked_id = 2;
inline bool TrackedFace::has_tracked_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackedFace::set_has_tracked_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackedFace::clear_has_tracked_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackedFace::clear_tracked_id() {
  tracked_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tracked_id();
}
inline const ::std::string& TrackedFace::tracked_id() const {
  // @@protoc_insertion_point(field_get:kf.TrackedFace.tracked_id)
  return tracked_id_.GetNoArena();
}
inline void TrackedFace::set_tracked_id(const ::std::string& value) {
  set_has_tracked_id();
  tracked_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.TrackedFace.tracked_id)
}
#if LANG_CXX11
inline void TrackedFace::set_tracked_id(::std::string&& value) {
  set_has_tracked_id();
  tracked_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.TrackedFace.tracked_id)
}
#endif
inline void TrackedFace::set_tracked_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tracked_id();
  tracked_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.TrackedFace.tracked_id)
}
inline void TrackedFace::set_tracked_id(const char* value, size_t size) {
  set_has_tracked_id();
  tracked_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.TrackedFace.tracked_id)
}
inline ::std::string* TrackedFace::mutable_tracked_id() {
  set_has_tracked_id();
  // @@protoc_insertion_point(field_mutable:kf.TrackedFace.tracked_id)
  return tracked_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrackedFace::release_tracked_id() {
  // @@protoc_insertion_point(field_release:kf.TrackedFace.tracked_id)
  if (!has_tracked_id()) {
    return NULL;
  }
  clear_has_tracked_id();
  return tracked_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrackedFace::set_allocated_tracked_id(::std::string* tracked_id) {
  if (tracked_id != NULL) {
    set_has_tracked_id();
  } else {
    clear_has_tracked_id();
  }
  tracked_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tracked_id);
  // @@protoc_insertion_point(field_set_allocated:kf.TrackedFace.tracked_id)
}

// -------------------------------------------------------------------

// BlackListFaceAlarm

// required string oid = 1;
inline bool BlackListFaceAlarm::has_oid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackListFaceAlarm::set_has_oid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackListFaceAlarm::clear_has_oid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackListFaceAlarm::clear_oid() {
  oid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oid();
}
inline const ::std::string& BlackListFaceAlarm::oid() const {
  // @@protoc_insertion_point(field_get:kf.BlackListFaceAlarm.oid)
  return oid_.GetNoArena();
}
inline void BlackListFaceAlarm::set_oid(const ::std::string& value) {
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.BlackListFaceAlarm.oid)
}
#if LANG_CXX11
inline void BlackListFaceAlarm::set_oid(::std::string&& value) {
  set_has_oid();
  oid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.BlackListFaceAlarm.oid)
}
#endif
inline void BlackListFaceAlarm::set_oid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.BlackListFaceAlarm.oid)
}
inline void BlackListFaceAlarm::set_oid(const char* value, size_t size) {
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.BlackListFaceAlarm.oid)
}
inline ::std::string* BlackListFaceAlarm::mutable_oid() {
  set_has_oid();
  // @@protoc_insertion_point(field_mutable:kf.BlackListFaceAlarm.oid)
  return oid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlackListFaceAlarm::release_oid() {
  // @@protoc_insertion_point(field_release:kf.BlackListFaceAlarm.oid)
  if (!has_oid()) {
    return NULL;
  }
  clear_has_oid();
  return oid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlackListFaceAlarm::set_allocated_oid(::std::string* oid) {
  if (oid != NULL) {
    set_has_oid();
  } else {
    clear_has_oid();
  }
  oid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oid);
  // @@protoc_insertion_point(field_set_allocated:kf.BlackListFaceAlarm.oid)
}

// required string camera_id = 2;
inline bool BlackListFaceAlarm::has_camera_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlackListFaceAlarm::set_has_camera_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlackListFaceAlarm::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlackListFaceAlarm::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& BlackListFaceAlarm::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.BlackListFaceAlarm.camera_id)
  return camera_id_.GetNoArena();
}
inline void BlackListFaceAlarm::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.BlackListFaceAlarm.camera_id)
}
#if LANG_CXX11
inline void BlackListFaceAlarm::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.BlackListFaceAlarm.camera_id)
}
#endif
inline void BlackListFaceAlarm::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.BlackListFaceAlarm.camera_id)
}
inline void BlackListFaceAlarm::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.BlackListFaceAlarm.camera_id)
}
inline ::std::string* BlackListFaceAlarm::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.BlackListFaceAlarm.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlackListFaceAlarm::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.BlackListFaceAlarm.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlackListFaceAlarm::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.BlackListFaceAlarm.camera_id)
}

// required string camera_pos = 3;
inline bool BlackListFaceAlarm::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlackListFaceAlarm::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlackListFaceAlarm::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlackListFaceAlarm::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& BlackListFaceAlarm::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.BlackListFaceAlarm.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void BlackListFaceAlarm::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.BlackListFaceAlarm.camera_pos)
}
#if LANG_CXX11
inline void BlackListFaceAlarm::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.BlackListFaceAlarm.camera_pos)
}
#endif
inline void BlackListFaceAlarm::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.BlackListFaceAlarm.camera_pos)
}
inline void BlackListFaceAlarm::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.BlackListFaceAlarm.camera_pos)
}
inline ::std::string* BlackListFaceAlarm::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.BlackListFaceAlarm.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlackListFaceAlarm::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.BlackListFaceAlarm.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlackListFaceAlarm::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.BlackListFaceAlarm.camera_pos)
}

// required bytes face_img = 4;
inline bool BlackListFaceAlarm::has_face_img() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlackListFaceAlarm::set_has_face_img() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlackListFaceAlarm::clear_has_face_img() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlackListFaceAlarm::clear_face_img() {
  face_img_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_face_img();
}
inline const ::std::string& BlackListFaceAlarm::face_img() const {
  // @@protoc_insertion_point(field_get:kf.BlackListFaceAlarm.face_img)
  return face_img_.GetNoArena();
}
inline void BlackListFaceAlarm::set_face_img(const ::std::string& value) {
  set_has_face_img();
  face_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.BlackListFaceAlarm.face_img)
}
#if LANG_CXX11
inline void BlackListFaceAlarm::set_face_img(::std::string&& value) {
  set_has_face_img();
  face_img_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.BlackListFaceAlarm.face_img)
}
#endif
inline void BlackListFaceAlarm::set_face_img(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_face_img();
  face_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.BlackListFaceAlarm.face_img)
}
inline void BlackListFaceAlarm::set_face_img(const void* value, size_t size) {
  set_has_face_img();
  face_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.BlackListFaceAlarm.face_img)
}
inline ::std::string* BlackListFaceAlarm::mutable_face_img() {
  set_has_face_img();
  // @@protoc_insertion_point(field_mutable:kf.BlackListFaceAlarm.face_img)
  return face_img_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlackListFaceAlarm::release_face_img() {
  // @@protoc_insertion_point(field_release:kf.BlackListFaceAlarm.face_img)
  if (!has_face_img()) {
    return NULL;
  }
  clear_has_face_img();
  return face_img_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlackListFaceAlarm::set_allocated_face_img(::std::string* face_img) {
  if (face_img != NULL) {
    set_has_face_img();
  } else {
    clear_has_face_img();
  }
  face_img_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), face_img);
  // @@protoc_insertion_point(field_set_allocated:kf.BlackListFaceAlarm.face_img)
}

// required bytes thumbnail_scene = 5;
inline bool BlackListFaceAlarm::has_thumbnail_scene() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlackListFaceAlarm::set_has_thumbnail_scene() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlackListFaceAlarm::clear_has_thumbnail_scene() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlackListFaceAlarm::clear_thumbnail_scene() {
  thumbnail_scene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_thumbnail_scene();
}
inline const ::std::string& BlackListFaceAlarm::thumbnail_scene() const {
  // @@protoc_insertion_point(field_get:kf.BlackListFaceAlarm.thumbnail_scene)
  return thumbnail_scene_.GetNoArena();
}
inline void BlackListFaceAlarm::set_thumbnail_scene(const ::std::string& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.BlackListFaceAlarm.thumbnail_scene)
}
#if LANG_CXX11
inline void BlackListFaceAlarm::set_thumbnail_scene(::std::string&& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.BlackListFaceAlarm.thumbnail_scene)
}
#endif
inline void BlackListFaceAlarm::set_thumbnail_scene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.BlackListFaceAlarm.thumbnail_scene)
}
inline void BlackListFaceAlarm::set_thumbnail_scene(const void* value, size_t size) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.BlackListFaceAlarm.thumbnail_scene)
}
inline ::std::string* BlackListFaceAlarm::mutable_thumbnail_scene() {
  set_has_thumbnail_scene();
  // @@protoc_insertion_point(field_mutable:kf.BlackListFaceAlarm.thumbnail_scene)
  return thumbnail_scene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlackListFaceAlarm::release_thumbnail_scene() {
  // @@protoc_insertion_point(field_release:kf.BlackListFaceAlarm.thumbnail_scene)
  if (!has_thumbnail_scene()) {
    return NULL;
  }
  clear_has_thumbnail_scene();
  return thumbnail_scene_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlackListFaceAlarm::set_allocated_thumbnail_scene(::std::string* thumbnail_scene) {
  if (thumbnail_scene != NULL) {
    set_has_thumbnail_scene();
  } else {
    clear_has_thumbnail_scene();
  }
  thumbnail_scene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_scene);
  // @@protoc_insertion_point(field_set_allocated:kf.BlackListFaceAlarm.thumbnail_scene)
}

// required int64 timestamp = 6;
inline bool BlackListFaceAlarm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlackListFaceAlarm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlackListFaceAlarm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlackListFaceAlarm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 BlackListFaceAlarm::timestamp() const {
  // @@protoc_insertion_point(field_get:kf.BlackListFaceAlarm.timestamp)
  return timestamp_;
}
inline void BlackListFaceAlarm::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:kf.BlackListFaceAlarm.timestamp)
}

// -------------------------------------------------------------------

// Intruder

// required string oid = 1;
inline bool Intruder::has_oid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Intruder::set_has_oid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Intruder::clear_has_oid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Intruder::clear_oid() {
  oid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oid();
}
inline const ::std::string& Intruder::oid() const {
  // @@protoc_insertion_point(field_get:kf.Intruder.oid)
  return oid_.GetNoArena();
}
inline void Intruder::set_oid(const ::std::string& value) {
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.Intruder.oid)
}
#if LANG_CXX11
inline void Intruder::set_oid(::std::string&& value) {
  set_has_oid();
  oid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.Intruder.oid)
}
#endif
inline void Intruder::set_oid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.Intruder.oid)
}
inline void Intruder::set_oid(const char* value, size_t size) {
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.Intruder.oid)
}
inline ::std::string* Intruder::mutable_oid() {
  set_has_oid();
  // @@protoc_insertion_point(field_mutable:kf.Intruder.oid)
  return oid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Intruder::release_oid() {
  // @@protoc_insertion_point(field_release:kf.Intruder.oid)
  if (!has_oid()) {
    return NULL;
  }
  clear_has_oid();
  return oid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Intruder::set_allocated_oid(::std::string* oid) {
  if (oid != NULL) {
    set_has_oid();
  } else {
    clear_has_oid();
  }
  oid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oid);
  // @@protoc_insertion_point(field_set_allocated:kf.Intruder.oid)
}

// required string camera_id = 2;
inline bool Intruder::has_camera_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Intruder::set_has_camera_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Intruder::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Intruder::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& Intruder::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.Intruder.camera_id)
  return camera_id_.GetNoArena();
}
inline void Intruder::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.Intruder.camera_id)
}
#if LANG_CXX11
inline void Intruder::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.Intruder.camera_id)
}
#endif
inline void Intruder::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.Intruder.camera_id)
}
inline void Intruder::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.Intruder.camera_id)
}
inline ::std::string* Intruder::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.Intruder.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Intruder::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.Intruder.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Intruder::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.Intruder.camera_id)
}

// required string camera_pos = 3;
inline bool Intruder::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Intruder::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Intruder::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Intruder::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& Intruder::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.Intruder.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void Intruder::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.Intruder.camera_pos)
}
#if LANG_CXX11
inline void Intruder::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.Intruder.camera_pos)
}
#endif
inline void Intruder::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.Intruder.camera_pos)
}
inline void Intruder::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.Intruder.camera_pos)
}
inline ::std::string* Intruder::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.Intruder.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Intruder::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.Intruder.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Intruder::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.Intruder.camera_pos)
}

// repeated bytes pseron_imgs = 4;
inline int Intruder::pseron_imgs_size() const {
  return pseron_imgs_.size();
}
inline void Intruder::clear_pseron_imgs() {
  pseron_imgs_.Clear();
}
inline const ::std::string& Intruder::pseron_imgs(int index) const {
  // @@protoc_insertion_point(field_get:kf.Intruder.pseron_imgs)
  return pseron_imgs_.Get(index);
}
inline ::std::string* Intruder::mutable_pseron_imgs(int index) {
  // @@protoc_insertion_point(field_mutable:kf.Intruder.pseron_imgs)
  return pseron_imgs_.Mutable(index);
}
inline void Intruder::set_pseron_imgs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kf.Intruder.pseron_imgs)
  pseron_imgs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Intruder::set_pseron_imgs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kf.Intruder.pseron_imgs)
  pseron_imgs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Intruder::set_pseron_imgs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  pseron_imgs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kf.Intruder.pseron_imgs)
}
inline void Intruder::set_pseron_imgs(int index, const void* value, size_t size) {
  pseron_imgs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kf.Intruder.pseron_imgs)
}
inline ::std::string* Intruder::add_pseron_imgs() {
  // @@protoc_insertion_point(field_add_mutable:kf.Intruder.pseron_imgs)
  return pseron_imgs_.Add();
}
inline void Intruder::add_pseron_imgs(const ::std::string& value) {
  pseron_imgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kf.Intruder.pseron_imgs)
}
#if LANG_CXX11
inline void Intruder::add_pseron_imgs(::std::string&& value) {
  pseron_imgs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kf.Intruder.pseron_imgs)
}
#endif
inline void Intruder::add_pseron_imgs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  pseron_imgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kf.Intruder.pseron_imgs)
}
inline void Intruder::add_pseron_imgs(const void* value, size_t size) {
  pseron_imgs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kf.Intruder.pseron_imgs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Intruder::pseron_imgs() const {
  // @@protoc_insertion_point(field_list:kf.Intruder.pseron_imgs)
  return pseron_imgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Intruder::mutable_pseron_imgs() {
  // @@protoc_insertion_point(field_mutable_list:kf.Intruder.pseron_imgs)
  return &pseron_imgs_;
}

// required bytes thumbnail_scene = 5;
inline bool Intruder::has_thumbnail_scene() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Intruder::set_has_thumbnail_scene() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Intruder::clear_has_thumbnail_scene() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Intruder::clear_thumbnail_scene() {
  thumbnail_scene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_thumbnail_scene();
}
inline const ::std::string& Intruder::thumbnail_scene() const {
  // @@protoc_insertion_point(field_get:kf.Intruder.thumbnail_scene)
  return thumbnail_scene_.GetNoArena();
}
inline void Intruder::set_thumbnail_scene(const ::std::string& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.Intruder.thumbnail_scene)
}
#if LANG_CXX11
inline void Intruder::set_thumbnail_scene(::std::string&& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.Intruder.thumbnail_scene)
}
#endif
inline void Intruder::set_thumbnail_scene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.Intruder.thumbnail_scene)
}
inline void Intruder::set_thumbnail_scene(const void* value, size_t size) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.Intruder.thumbnail_scene)
}
inline ::std::string* Intruder::mutable_thumbnail_scene() {
  set_has_thumbnail_scene();
  // @@protoc_insertion_point(field_mutable:kf.Intruder.thumbnail_scene)
  return thumbnail_scene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Intruder::release_thumbnail_scene() {
  // @@protoc_insertion_point(field_release:kf.Intruder.thumbnail_scene)
  if (!has_thumbnail_scene()) {
    return NULL;
  }
  clear_has_thumbnail_scene();
  return thumbnail_scene_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Intruder::set_allocated_thumbnail_scene(::std::string* thumbnail_scene) {
  if (thumbnail_scene != NULL) {
    set_has_thumbnail_scene();
  } else {
    clear_has_thumbnail_scene();
  }
  thumbnail_scene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_scene);
  // @@protoc_insertion_point(field_set_allocated:kf.Intruder.thumbnail_scene)
}

// required int64 timestamp = 6;
inline bool Intruder::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Intruder::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Intruder::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Intruder::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Intruder::timestamp() const {
  // @@protoc_insertion_point(field_get:kf.Intruder.timestamp)
  return timestamp_;
}
inline void Intruder::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:kf.Intruder.timestamp)
}

// -------------------------------------------------------------------

// ABDoorAlarm

// required string oid = 1;
inline bool ABDoorAlarm::has_oid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ABDoorAlarm::set_has_oid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ABDoorAlarm::clear_has_oid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ABDoorAlarm::clear_oid() {
  oid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oid();
}
inline const ::std::string& ABDoorAlarm::oid() const {
  // @@protoc_insertion_point(field_get:kf.ABDoorAlarm.oid)
  return oid_.GetNoArena();
}
inline void ABDoorAlarm::set_oid(const ::std::string& value) {
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.ABDoorAlarm.oid)
}
#if LANG_CXX11
inline void ABDoorAlarm::set_oid(::std::string&& value) {
  set_has_oid();
  oid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.ABDoorAlarm.oid)
}
#endif
inline void ABDoorAlarm::set_oid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.ABDoorAlarm.oid)
}
inline void ABDoorAlarm::set_oid(const char* value, size_t size) {
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.ABDoorAlarm.oid)
}
inline ::std::string* ABDoorAlarm::mutable_oid() {
  set_has_oid();
  // @@protoc_insertion_point(field_mutable:kf.ABDoorAlarm.oid)
  return oid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ABDoorAlarm::release_oid() {
  // @@protoc_insertion_point(field_release:kf.ABDoorAlarm.oid)
  if (!has_oid()) {
    return NULL;
  }
  clear_has_oid();
  return oid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ABDoorAlarm::set_allocated_oid(::std::string* oid) {
  if (oid != NULL) {
    set_has_oid();
  } else {
    clear_has_oid();
  }
  oid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oid);
  // @@protoc_insertion_point(field_set_allocated:kf.ABDoorAlarm.oid)
}

// required string camera_id = 2;
inline bool ABDoorAlarm::has_camera_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ABDoorAlarm::set_has_camera_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ABDoorAlarm::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ABDoorAlarm::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& ABDoorAlarm::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.ABDoorAlarm.camera_id)
  return camera_id_.GetNoArena();
}
inline void ABDoorAlarm::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.ABDoorAlarm.camera_id)
}
#if LANG_CXX11
inline void ABDoorAlarm::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.ABDoorAlarm.camera_id)
}
#endif
inline void ABDoorAlarm::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.ABDoorAlarm.camera_id)
}
inline void ABDoorAlarm::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.ABDoorAlarm.camera_id)
}
inline ::std::string* ABDoorAlarm::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.ABDoorAlarm.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ABDoorAlarm::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.ABDoorAlarm.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ABDoorAlarm::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.ABDoorAlarm.camera_id)
}

// required string camera_pos = 3;
inline bool ABDoorAlarm::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ABDoorAlarm::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ABDoorAlarm::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ABDoorAlarm::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& ABDoorAlarm::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.ABDoorAlarm.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void ABDoorAlarm::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.ABDoorAlarm.camera_pos)
}
#if LANG_CXX11
inline void ABDoorAlarm::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.ABDoorAlarm.camera_pos)
}
#endif
inline void ABDoorAlarm::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.ABDoorAlarm.camera_pos)
}
inline void ABDoorAlarm::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.ABDoorAlarm.camera_pos)
}
inline ::std::string* ABDoorAlarm::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.ABDoorAlarm.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ABDoorAlarm::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.ABDoorAlarm.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ABDoorAlarm::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.ABDoorAlarm.camera_pos)
}

// required bytes pseron_img = 4;
inline bool ABDoorAlarm::has_pseron_img() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ABDoorAlarm::set_has_pseron_img() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ABDoorAlarm::clear_has_pseron_img() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ABDoorAlarm::clear_pseron_img() {
  pseron_img_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pseron_img();
}
inline const ::std::string& ABDoorAlarm::pseron_img() const {
  // @@protoc_insertion_point(field_get:kf.ABDoorAlarm.pseron_img)
  return pseron_img_.GetNoArena();
}
inline void ABDoorAlarm::set_pseron_img(const ::std::string& value) {
  set_has_pseron_img();
  pseron_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.ABDoorAlarm.pseron_img)
}
#if LANG_CXX11
inline void ABDoorAlarm::set_pseron_img(::std::string&& value) {
  set_has_pseron_img();
  pseron_img_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.ABDoorAlarm.pseron_img)
}
#endif
inline void ABDoorAlarm::set_pseron_img(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pseron_img();
  pseron_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.ABDoorAlarm.pseron_img)
}
inline void ABDoorAlarm::set_pseron_img(const void* value, size_t size) {
  set_has_pseron_img();
  pseron_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.ABDoorAlarm.pseron_img)
}
inline ::std::string* ABDoorAlarm::mutable_pseron_img() {
  set_has_pseron_img();
  // @@protoc_insertion_point(field_mutable:kf.ABDoorAlarm.pseron_img)
  return pseron_img_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ABDoorAlarm::release_pseron_img() {
  // @@protoc_insertion_point(field_release:kf.ABDoorAlarm.pseron_img)
  if (!has_pseron_img()) {
    return NULL;
  }
  clear_has_pseron_img();
  return pseron_img_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ABDoorAlarm::set_allocated_pseron_img(::std::string* pseron_img) {
  if (pseron_img != NULL) {
    set_has_pseron_img();
  } else {
    clear_has_pseron_img();
  }
  pseron_img_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseron_img);
  // @@protoc_insertion_point(field_set_allocated:kf.ABDoorAlarm.pseron_img)
}

// required bytes thumbnail_scene = 5;
inline bool ABDoorAlarm::has_thumbnail_scene() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ABDoorAlarm::set_has_thumbnail_scene() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ABDoorAlarm::clear_has_thumbnail_scene() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ABDoorAlarm::clear_thumbnail_scene() {
  thumbnail_scene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_thumbnail_scene();
}
inline const ::std::string& ABDoorAlarm::thumbnail_scene() const {
  // @@protoc_insertion_point(field_get:kf.ABDoorAlarm.thumbnail_scene)
  return thumbnail_scene_.GetNoArena();
}
inline void ABDoorAlarm::set_thumbnail_scene(const ::std::string& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.ABDoorAlarm.thumbnail_scene)
}
#if LANG_CXX11
inline void ABDoorAlarm::set_thumbnail_scene(::std::string&& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.ABDoorAlarm.thumbnail_scene)
}
#endif
inline void ABDoorAlarm::set_thumbnail_scene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.ABDoorAlarm.thumbnail_scene)
}
inline void ABDoorAlarm::set_thumbnail_scene(const void* value, size_t size) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.ABDoorAlarm.thumbnail_scene)
}
inline ::std::string* ABDoorAlarm::mutable_thumbnail_scene() {
  set_has_thumbnail_scene();
  // @@protoc_insertion_point(field_mutable:kf.ABDoorAlarm.thumbnail_scene)
  return thumbnail_scene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ABDoorAlarm::release_thumbnail_scene() {
  // @@protoc_insertion_point(field_release:kf.ABDoorAlarm.thumbnail_scene)
  if (!has_thumbnail_scene()) {
    return NULL;
  }
  clear_has_thumbnail_scene();
  return thumbnail_scene_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ABDoorAlarm::set_allocated_thumbnail_scene(::std::string* thumbnail_scene) {
  if (thumbnail_scene != NULL) {
    set_has_thumbnail_scene();
  } else {
    clear_has_thumbnail_scene();
  }
  thumbnail_scene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_scene);
  // @@protoc_insertion_point(field_set_allocated:kf.ABDoorAlarm.thumbnail_scene)
}

// required int64 timestamp = 6;
inline bool ABDoorAlarm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ABDoorAlarm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ABDoorAlarm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ABDoorAlarm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ABDoorAlarm::timestamp() const {
  // @@protoc_insertion_point(field_get:kf.ABDoorAlarm.timestamp)
  return timestamp_;
}
inline void ABDoorAlarm::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:kf.ABDoorAlarm.timestamp)
}

// -------------------------------------------------------------------

// StopAlarm

// required string camera_id = 1;
inline bool StopAlarm::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopAlarm::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopAlarm::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopAlarm::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& StopAlarm::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.StopAlarm.camera_id)
  return camera_id_.GetNoArena();
}
inline void StopAlarm::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.StopAlarm.camera_id)
}
#if LANG_CXX11
inline void StopAlarm::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.StopAlarm.camera_id)
}
#endif
inline void StopAlarm::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.StopAlarm.camera_id)
}
inline void StopAlarm::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.StopAlarm.camera_id)
}
inline ::std::string* StopAlarm::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.StopAlarm.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopAlarm::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.StopAlarm.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopAlarm::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.StopAlarm.camera_id)
}

// required string camera_pos = 2;
inline bool StopAlarm::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopAlarm::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopAlarm::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopAlarm::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& StopAlarm::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.StopAlarm.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void StopAlarm::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.StopAlarm.camera_pos)
}
#if LANG_CXX11
inline void StopAlarm::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.StopAlarm.camera_pos)
}
#endif
inline void StopAlarm::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.StopAlarm.camera_pos)
}
inline void StopAlarm::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.StopAlarm.camera_pos)
}
inline ::std::string* StopAlarm::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.StopAlarm.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopAlarm::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.StopAlarm.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopAlarm::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.StopAlarm.camera_pos)
}

// repeated bytes person_imgs = 3;
inline int StopAlarm::person_imgs_size() const {
  return person_imgs_.size();
}
inline void StopAlarm::clear_person_imgs() {
  person_imgs_.Clear();
}
inline const ::std::string& StopAlarm::person_imgs(int index) const {
  // @@protoc_insertion_point(field_get:kf.StopAlarm.person_imgs)
  return person_imgs_.Get(index);
}
inline ::std::string* StopAlarm::mutable_person_imgs(int index) {
  // @@protoc_insertion_point(field_mutable:kf.StopAlarm.person_imgs)
  return person_imgs_.Mutable(index);
}
inline void StopAlarm::set_person_imgs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kf.StopAlarm.person_imgs)
  person_imgs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StopAlarm::set_person_imgs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kf.StopAlarm.person_imgs)
  person_imgs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StopAlarm::set_person_imgs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  person_imgs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kf.StopAlarm.person_imgs)
}
inline void StopAlarm::set_person_imgs(int index, const void* value, size_t size) {
  person_imgs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kf.StopAlarm.person_imgs)
}
inline ::std::string* StopAlarm::add_person_imgs() {
  // @@protoc_insertion_point(field_add_mutable:kf.StopAlarm.person_imgs)
  return person_imgs_.Add();
}
inline void StopAlarm::add_person_imgs(const ::std::string& value) {
  person_imgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kf.StopAlarm.person_imgs)
}
#if LANG_CXX11
inline void StopAlarm::add_person_imgs(::std::string&& value) {
  person_imgs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kf.StopAlarm.person_imgs)
}
#endif
inline void StopAlarm::add_person_imgs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  person_imgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kf.StopAlarm.person_imgs)
}
inline void StopAlarm::add_person_imgs(const void* value, size_t size) {
  person_imgs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kf.StopAlarm.person_imgs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StopAlarm::person_imgs() const {
  // @@protoc_insertion_point(field_list:kf.StopAlarm.person_imgs)
  return person_imgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StopAlarm::mutable_person_imgs() {
  // @@protoc_insertion_point(field_mutable_list:kf.StopAlarm.person_imgs)
  return &person_imgs_;
}

// required bytes thumbnail_scene = 4;
inline bool StopAlarm::has_thumbnail_scene() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StopAlarm::set_has_thumbnail_scene() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StopAlarm::clear_has_thumbnail_scene() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StopAlarm::clear_thumbnail_scene() {
  thumbnail_scene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_thumbnail_scene();
}
inline const ::std::string& StopAlarm::thumbnail_scene() const {
  // @@protoc_insertion_point(field_get:kf.StopAlarm.thumbnail_scene)
  return thumbnail_scene_.GetNoArena();
}
inline void StopAlarm::set_thumbnail_scene(const ::std::string& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.StopAlarm.thumbnail_scene)
}
#if LANG_CXX11
inline void StopAlarm::set_thumbnail_scene(::std::string&& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.StopAlarm.thumbnail_scene)
}
#endif
inline void StopAlarm::set_thumbnail_scene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.StopAlarm.thumbnail_scene)
}
inline void StopAlarm::set_thumbnail_scene(const void* value, size_t size) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.StopAlarm.thumbnail_scene)
}
inline ::std::string* StopAlarm::mutable_thumbnail_scene() {
  set_has_thumbnail_scene();
  // @@protoc_insertion_point(field_mutable:kf.StopAlarm.thumbnail_scene)
  return thumbnail_scene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopAlarm::release_thumbnail_scene() {
  // @@protoc_insertion_point(field_release:kf.StopAlarm.thumbnail_scene)
  if (!has_thumbnail_scene()) {
    return NULL;
  }
  clear_has_thumbnail_scene();
  return thumbnail_scene_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopAlarm::set_allocated_thumbnail_scene(::std::string* thumbnail_scene) {
  if (thumbnail_scene != NULL) {
    set_has_thumbnail_scene();
  } else {
    clear_has_thumbnail_scene();
  }
  thumbnail_scene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_scene);
  // @@protoc_insertion_point(field_set_allocated:kf.StopAlarm.thumbnail_scene)
}

// required int64 timestamp = 5;
inline bool StopAlarm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StopAlarm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StopAlarm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StopAlarm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 StopAlarm::timestamp() const {
  // @@protoc_insertion_point(field_get:kf.StopAlarm.timestamp)
  return timestamp_;
}
inline void StopAlarm::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:kf.StopAlarm.timestamp)
}

// -------------------------------------------------------------------

// ClimbAlarm

// required string camera_id = 1;
inline bool ClimbAlarm::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClimbAlarm::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClimbAlarm::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClimbAlarm::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& ClimbAlarm::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.ClimbAlarm.camera_id)
  return camera_id_.GetNoArena();
}
inline void ClimbAlarm::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.ClimbAlarm.camera_id)
}
#if LANG_CXX11
inline void ClimbAlarm::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.ClimbAlarm.camera_id)
}
#endif
inline void ClimbAlarm::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.ClimbAlarm.camera_id)
}
inline void ClimbAlarm::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.ClimbAlarm.camera_id)
}
inline ::std::string* ClimbAlarm::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.ClimbAlarm.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClimbAlarm::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.ClimbAlarm.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClimbAlarm::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.ClimbAlarm.camera_id)
}

// required string camera_pos = 2;
inline bool ClimbAlarm::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClimbAlarm::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClimbAlarm::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClimbAlarm::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& ClimbAlarm::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.ClimbAlarm.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void ClimbAlarm::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.ClimbAlarm.camera_pos)
}
#if LANG_CXX11
inline void ClimbAlarm::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.ClimbAlarm.camera_pos)
}
#endif
inline void ClimbAlarm::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.ClimbAlarm.camera_pos)
}
inline void ClimbAlarm::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.ClimbAlarm.camera_pos)
}
inline ::std::string* ClimbAlarm::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.ClimbAlarm.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClimbAlarm::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.ClimbAlarm.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClimbAlarm::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.ClimbAlarm.camera_pos)
}

// repeated bytes person_imgs = 3;
inline int ClimbAlarm::person_imgs_size() const {
  return person_imgs_.size();
}
inline void ClimbAlarm::clear_person_imgs() {
  person_imgs_.Clear();
}
inline const ::std::string& ClimbAlarm::person_imgs(int index) const {
  // @@protoc_insertion_point(field_get:kf.ClimbAlarm.person_imgs)
  return person_imgs_.Get(index);
}
inline ::std::string* ClimbAlarm::mutable_person_imgs(int index) {
  // @@protoc_insertion_point(field_mutable:kf.ClimbAlarm.person_imgs)
  return person_imgs_.Mutable(index);
}
inline void ClimbAlarm::set_person_imgs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kf.ClimbAlarm.person_imgs)
  person_imgs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ClimbAlarm::set_person_imgs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kf.ClimbAlarm.person_imgs)
  person_imgs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ClimbAlarm::set_person_imgs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  person_imgs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kf.ClimbAlarm.person_imgs)
}
inline void ClimbAlarm::set_person_imgs(int index, const void* value, size_t size) {
  person_imgs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kf.ClimbAlarm.person_imgs)
}
inline ::std::string* ClimbAlarm::add_person_imgs() {
  // @@protoc_insertion_point(field_add_mutable:kf.ClimbAlarm.person_imgs)
  return person_imgs_.Add();
}
inline void ClimbAlarm::add_person_imgs(const ::std::string& value) {
  person_imgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kf.ClimbAlarm.person_imgs)
}
#if LANG_CXX11
inline void ClimbAlarm::add_person_imgs(::std::string&& value) {
  person_imgs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kf.ClimbAlarm.person_imgs)
}
#endif
inline void ClimbAlarm::add_person_imgs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  person_imgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kf.ClimbAlarm.person_imgs)
}
inline void ClimbAlarm::add_person_imgs(const void* value, size_t size) {
  person_imgs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kf.ClimbAlarm.person_imgs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClimbAlarm::person_imgs() const {
  // @@protoc_insertion_point(field_list:kf.ClimbAlarm.person_imgs)
  return person_imgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClimbAlarm::mutable_person_imgs() {
  // @@protoc_insertion_point(field_mutable_list:kf.ClimbAlarm.person_imgs)
  return &person_imgs_;
}

// required bytes thumbnail_scene = 4;
inline bool ClimbAlarm::has_thumbnail_scene() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClimbAlarm::set_has_thumbnail_scene() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClimbAlarm::clear_has_thumbnail_scene() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClimbAlarm::clear_thumbnail_scene() {
  thumbnail_scene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_thumbnail_scene();
}
inline const ::std::string& ClimbAlarm::thumbnail_scene() const {
  // @@protoc_insertion_point(field_get:kf.ClimbAlarm.thumbnail_scene)
  return thumbnail_scene_.GetNoArena();
}
inline void ClimbAlarm::set_thumbnail_scene(const ::std::string& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.ClimbAlarm.thumbnail_scene)
}
#if LANG_CXX11
inline void ClimbAlarm::set_thumbnail_scene(::std::string&& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.ClimbAlarm.thumbnail_scene)
}
#endif
inline void ClimbAlarm::set_thumbnail_scene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.ClimbAlarm.thumbnail_scene)
}
inline void ClimbAlarm::set_thumbnail_scene(const void* value, size_t size) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.ClimbAlarm.thumbnail_scene)
}
inline ::std::string* ClimbAlarm::mutable_thumbnail_scene() {
  set_has_thumbnail_scene();
  // @@protoc_insertion_point(field_mutable:kf.ClimbAlarm.thumbnail_scene)
  return thumbnail_scene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClimbAlarm::release_thumbnail_scene() {
  // @@protoc_insertion_point(field_release:kf.ClimbAlarm.thumbnail_scene)
  if (!has_thumbnail_scene()) {
    return NULL;
  }
  clear_has_thumbnail_scene();
  return thumbnail_scene_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClimbAlarm::set_allocated_thumbnail_scene(::std::string* thumbnail_scene) {
  if (thumbnail_scene != NULL) {
    set_has_thumbnail_scene();
  } else {
    clear_has_thumbnail_scene();
  }
  thumbnail_scene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_scene);
  // @@protoc_insertion_point(field_set_allocated:kf.ClimbAlarm.thumbnail_scene)
}

// required int64 timestamp = 5;
inline bool ClimbAlarm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClimbAlarm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClimbAlarm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClimbAlarm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ClimbAlarm::timestamp() const {
  // @@protoc_insertion_point(field_get:kf.ClimbAlarm.timestamp)
  return timestamp_;
}
inline void ClimbAlarm::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:kf.ClimbAlarm.timestamp)
}

// -------------------------------------------------------------------

// LingerAlarm

// required string camera_id = 1;
inline bool LingerAlarm::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LingerAlarm::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LingerAlarm::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LingerAlarm::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& LingerAlarm::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.LingerAlarm.camera_id)
  return camera_id_.GetNoArena();
}
inline void LingerAlarm::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.LingerAlarm.camera_id)
}
#if LANG_CXX11
inline void LingerAlarm::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.LingerAlarm.camera_id)
}
#endif
inline void LingerAlarm::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.LingerAlarm.camera_id)
}
inline void LingerAlarm::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.LingerAlarm.camera_id)
}
inline ::std::string* LingerAlarm::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.LingerAlarm.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LingerAlarm::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.LingerAlarm.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LingerAlarm::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.LingerAlarm.camera_id)
}

// required string camera_pos = 2;
inline bool LingerAlarm::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LingerAlarm::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LingerAlarm::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LingerAlarm::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& LingerAlarm::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.LingerAlarm.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void LingerAlarm::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.LingerAlarm.camera_pos)
}
#if LANG_CXX11
inline void LingerAlarm::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.LingerAlarm.camera_pos)
}
#endif
inline void LingerAlarm::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.LingerAlarm.camera_pos)
}
inline void LingerAlarm::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.LingerAlarm.camera_pos)
}
inline ::std::string* LingerAlarm::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.LingerAlarm.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LingerAlarm::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.LingerAlarm.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LingerAlarm::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.LingerAlarm.camera_pos)
}

// repeated bytes person_imgs = 3;
inline int LingerAlarm::person_imgs_size() const {
  return person_imgs_.size();
}
inline void LingerAlarm::clear_person_imgs() {
  person_imgs_.Clear();
}
inline const ::std::string& LingerAlarm::person_imgs(int index) const {
  // @@protoc_insertion_point(field_get:kf.LingerAlarm.person_imgs)
  return person_imgs_.Get(index);
}
inline ::std::string* LingerAlarm::mutable_person_imgs(int index) {
  // @@protoc_insertion_point(field_mutable:kf.LingerAlarm.person_imgs)
  return person_imgs_.Mutable(index);
}
inline void LingerAlarm::set_person_imgs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kf.LingerAlarm.person_imgs)
  person_imgs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LingerAlarm::set_person_imgs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kf.LingerAlarm.person_imgs)
  person_imgs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LingerAlarm::set_person_imgs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  person_imgs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kf.LingerAlarm.person_imgs)
}
inline void LingerAlarm::set_person_imgs(int index, const void* value, size_t size) {
  person_imgs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kf.LingerAlarm.person_imgs)
}
inline ::std::string* LingerAlarm::add_person_imgs() {
  // @@protoc_insertion_point(field_add_mutable:kf.LingerAlarm.person_imgs)
  return person_imgs_.Add();
}
inline void LingerAlarm::add_person_imgs(const ::std::string& value) {
  person_imgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kf.LingerAlarm.person_imgs)
}
#if LANG_CXX11
inline void LingerAlarm::add_person_imgs(::std::string&& value) {
  person_imgs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kf.LingerAlarm.person_imgs)
}
#endif
inline void LingerAlarm::add_person_imgs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  person_imgs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kf.LingerAlarm.person_imgs)
}
inline void LingerAlarm::add_person_imgs(const void* value, size_t size) {
  person_imgs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kf.LingerAlarm.person_imgs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LingerAlarm::person_imgs() const {
  // @@protoc_insertion_point(field_list:kf.LingerAlarm.person_imgs)
  return person_imgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LingerAlarm::mutable_person_imgs() {
  // @@protoc_insertion_point(field_mutable_list:kf.LingerAlarm.person_imgs)
  return &person_imgs_;
}

// required bytes thumbnail_scene = 4;
inline bool LingerAlarm::has_thumbnail_scene() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LingerAlarm::set_has_thumbnail_scene() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LingerAlarm::clear_has_thumbnail_scene() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LingerAlarm::clear_thumbnail_scene() {
  thumbnail_scene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_thumbnail_scene();
}
inline const ::std::string& LingerAlarm::thumbnail_scene() const {
  // @@protoc_insertion_point(field_get:kf.LingerAlarm.thumbnail_scene)
  return thumbnail_scene_.GetNoArena();
}
inline void LingerAlarm::set_thumbnail_scene(const ::std::string& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.LingerAlarm.thumbnail_scene)
}
#if LANG_CXX11
inline void LingerAlarm::set_thumbnail_scene(::std::string&& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.LingerAlarm.thumbnail_scene)
}
#endif
inline void LingerAlarm::set_thumbnail_scene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.LingerAlarm.thumbnail_scene)
}
inline void LingerAlarm::set_thumbnail_scene(const void* value, size_t size) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.LingerAlarm.thumbnail_scene)
}
inline ::std::string* LingerAlarm::mutable_thumbnail_scene() {
  set_has_thumbnail_scene();
  // @@protoc_insertion_point(field_mutable:kf.LingerAlarm.thumbnail_scene)
  return thumbnail_scene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LingerAlarm::release_thumbnail_scene() {
  // @@protoc_insertion_point(field_release:kf.LingerAlarm.thumbnail_scene)
  if (!has_thumbnail_scene()) {
    return NULL;
  }
  clear_has_thumbnail_scene();
  return thumbnail_scene_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LingerAlarm::set_allocated_thumbnail_scene(::std::string* thumbnail_scene) {
  if (thumbnail_scene != NULL) {
    set_has_thumbnail_scene();
  } else {
    clear_has_thumbnail_scene();
  }
  thumbnail_scene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_scene);
  // @@protoc_insertion_point(field_set_allocated:kf.LingerAlarm.thumbnail_scene)
}

// required int64 timestamp = 5;
inline bool LingerAlarm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LingerAlarm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LingerAlarm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LingerAlarm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LingerAlarm::timestamp() const {
  // @@protoc_insertion_point(field_get:kf.LingerAlarm.timestamp)
  return timestamp_;
}
inline void LingerAlarm::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:kf.LingerAlarm.timestamp)
}

// -------------------------------------------------------------------

// GatherAlarm

// required string camera_id = 1;
inline bool GatherAlarm::has_camera_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GatherAlarm::set_has_camera_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GatherAlarm::clear_has_camera_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GatherAlarm::clear_camera_id() {
  camera_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_id();
}
inline const ::std::string& GatherAlarm::camera_id() const {
  // @@protoc_insertion_point(field_get:kf.GatherAlarm.camera_id)
  return camera_id_.GetNoArena();
}
inline void GatherAlarm::set_camera_id(const ::std::string& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.GatherAlarm.camera_id)
}
#if LANG_CXX11
inline void GatherAlarm::set_camera_id(::std::string&& value) {
  set_has_camera_id();
  camera_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.GatherAlarm.camera_id)
}
#endif
inline void GatherAlarm::set_camera_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.GatherAlarm.camera_id)
}
inline void GatherAlarm::set_camera_id(const char* value, size_t size) {
  set_has_camera_id();
  camera_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.GatherAlarm.camera_id)
}
inline ::std::string* GatherAlarm::mutable_camera_id() {
  set_has_camera_id();
  // @@protoc_insertion_point(field_mutable:kf.GatherAlarm.camera_id)
  return camera_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GatherAlarm::release_camera_id() {
  // @@protoc_insertion_point(field_release:kf.GatherAlarm.camera_id)
  if (!has_camera_id()) {
    return NULL;
  }
  clear_has_camera_id();
  return camera_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GatherAlarm::set_allocated_camera_id(::std::string* camera_id) {
  if (camera_id != NULL) {
    set_has_camera_id();
  } else {
    clear_has_camera_id();
  }
  camera_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_id);
  // @@protoc_insertion_point(field_set_allocated:kf.GatherAlarm.camera_id)
}

// required string camera_pos = 2;
inline bool GatherAlarm::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GatherAlarm::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GatherAlarm::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GatherAlarm::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& GatherAlarm::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.GatherAlarm.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void GatherAlarm::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.GatherAlarm.camera_pos)
}
#if LANG_CXX11
inline void GatherAlarm::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.GatherAlarm.camera_pos)
}
#endif
inline void GatherAlarm::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.GatherAlarm.camera_pos)
}
inline void GatherAlarm::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.GatherAlarm.camera_pos)
}
inline ::std::string* GatherAlarm::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.GatherAlarm.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GatherAlarm::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.GatherAlarm.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GatherAlarm::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.GatherAlarm.camera_pos)
}

// required bytes person_img = 3;
inline bool GatherAlarm::has_person_img() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GatherAlarm::set_has_person_img() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GatherAlarm::clear_has_person_img() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GatherAlarm::clear_person_img() {
  person_img_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_person_img();
}
inline const ::std::string& GatherAlarm::person_img() const {
  // @@protoc_insertion_point(field_get:kf.GatherAlarm.person_img)
  return person_img_.GetNoArena();
}
inline void GatherAlarm::set_person_img(const ::std::string& value) {
  set_has_person_img();
  person_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.GatherAlarm.person_img)
}
#if LANG_CXX11
inline void GatherAlarm::set_person_img(::std::string&& value) {
  set_has_person_img();
  person_img_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.GatherAlarm.person_img)
}
#endif
inline void GatherAlarm::set_person_img(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_person_img();
  person_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.GatherAlarm.person_img)
}
inline void GatherAlarm::set_person_img(const void* value, size_t size) {
  set_has_person_img();
  person_img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.GatherAlarm.person_img)
}
inline ::std::string* GatherAlarm::mutable_person_img() {
  set_has_person_img();
  // @@protoc_insertion_point(field_mutable:kf.GatherAlarm.person_img)
  return person_img_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GatherAlarm::release_person_img() {
  // @@protoc_insertion_point(field_release:kf.GatherAlarm.person_img)
  if (!has_person_img()) {
    return NULL;
  }
  clear_has_person_img();
  return person_img_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GatherAlarm::set_allocated_person_img(::std::string* person_img) {
  if (person_img != NULL) {
    set_has_person_img();
  } else {
    clear_has_person_img();
  }
  person_img_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), person_img);
  // @@protoc_insertion_point(field_set_allocated:kf.GatherAlarm.person_img)
}

// required bytes thumbnail_scene = 4;
inline bool GatherAlarm::has_thumbnail_scene() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GatherAlarm::set_has_thumbnail_scene() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GatherAlarm::clear_has_thumbnail_scene() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GatherAlarm::clear_thumbnail_scene() {
  thumbnail_scene_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_thumbnail_scene();
}
inline const ::std::string& GatherAlarm::thumbnail_scene() const {
  // @@protoc_insertion_point(field_get:kf.GatherAlarm.thumbnail_scene)
  return thumbnail_scene_.GetNoArena();
}
inline void GatherAlarm::set_thumbnail_scene(const ::std::string& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.GatherAlarm.thumbnail_scene)
}
#if LANG_CXX11
inline void GatherAlarm::set_thumbnail_scene(::std::string&& value) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.GatherAlarm.thumbnail_scene)
}
#endif
inline void GatherAlarm::set_thumbnail_scene(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.GatherAlarm.thumbnail_scene)
}
inline void GatherAlarm::set_thumbnail_scene(const void* value, size_t size) {
  set_has_thumbnail_scene();
  thumbnail_scene_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.GatherAlarm.thumbnail_scene)
}
inline ::std::string* GatherAlarm::mutable_thumbnail_scene() {
  set_has_thumbnail_scene();
  // @@protoc_insertion_point(field_mutable:kf.GatherAlarm.thumbnail_scene)
  return thumbnail_scene_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GatherAlarm::release_thumbnail_scene() {
  // @@protoc_insertion_point(field_release:kf.GatherAlarm.thumbnail_scene)
  if (!has_thumbnail_scene()) {
    return NULL;
  }
  clear_has_thumbnail_scene();
  return thumbnail_scene_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GatherAlarm::set_allocated_thumbnail_scene(::std::string* thumbnail_scene) {
  if (thumbnail_scene != NULL) {
    set_has_thumbnail_scene();
  } else {
    clear_has_thumbnail_scene();
  }
  thumbnail_scene_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_scene);
  // @@protoc_insertion_point(field_set_allocated:kf.GatherAlarm.thumbnail_scene)
}

// required int64 timestamp = 5;
inline bool GatherAlarm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GatherAlarm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GatherAlarm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GatherAlarm::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 GatherAlarm::timestamp() const {
  // @@protoc_insertion_point(field_get:kf.GatherAlarm.timestamp)
  return timestamp_;
}
inline void GatherAlarm::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:kf.GatherAlarm.timestamp)
}

// -------------------------------------------------------------------

// TodayTotalEventCount

// required int32 total_count = 1;
inline bool TodayTotalEventCount::has_total_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TodayTotalEventCount::set_has_total_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TodayTotalEventCount::clear_has_total_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TodayTotalEventCount::clear_total_count() {
  total_count_ = 0;
  clear_has_total_count();
}
inline ::google::protobuf::int32 TodayTotalEventCount::total_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayTotalEventCount.total_count)
  return total_count_;
}
inline void TodayTotalEventCount::set_total_count(::google::protobuf::int32 value) {
  set_has_total_count();
  total_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayTotalEventCount.total_count)
}

// required int32 blacklist_count = 2;
inline bool TodayTotalEventCount::has_blacklist_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TodayTotalEventCount::set_has_blacklist_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TodayTotalEventCount::clear_has_blacklist_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TodayTotalEventCount::clear_blacklist_count() {
  blacklist_count_ = 0;
  clear_has_blacklist_count();
}
inline ::google::protobuf::int32 TodayTotalEventCount::blacklist_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayTotalEventCount.blacklist_count)
  return blacklist_count_;
}
inline void TodayTotalEventCount::set_blacklist_count(::google::protobuf::int32 value) {
  set_has_blacklist_count();
  blacklist_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayTotalEventCount.blacklist_count)
}

// -------------------------------------------------------------------

// OneDayEventCount

// repeated int32 event_count = 1;
inline int OneDayEventCount::event_count_size() const {
  return event_count_.size();
}
inline void OneDayEventCount::clear_event_count() {
  event_count_.Clear();
}
inline ::google::protobuf::int32 OneDayEventCount::event_count(int index) const {
  // @@protoc_insertion_point(field_get:kf.OneDayEventCount.event_count)
  return event_count_.Get(index);
}
inline void OneDayEventCount::set_event_count(int index, ::google::protobuf::int32 value) {
  event_count_.Set(index, value);
  // @@protoc_insertion_point(field_set:kf.OneDayEventCount.event_count)
}
inline void OneDayEventCount::add_event_count(::google::protobuf::int32 value) {
  event_count_.Add(value);
  // @@protoc_insertion_point(field_add:kf.OneDayEventCount.event_count)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OneDayEventCount::event_count() const {
  // @@protoc_insertion_point(field_list:kf.OneDayEventCount.event_count)
  return event_count_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OneDayEventCount::mutable_event_count() {
  // @@protoc_insertion_point(field_mutable_list:kf.OneDayEventCount.event_count)
  return &event_count_;
}

// -------------------------------------------------------------------

// EventSpiderGiagram

// repeated .kf.OneDayEventCount someday_count = 1;
inline int EventSpiderGiagram::someday_count_size() const {
  return someday_count_.size();
}
inline void EventSpiderGiagram::clear_someday_count() {
  someday_count_.Clear();
}
inline ::kf::OneDayEventCount* EventSpiderGiagram::mutable_someday_count(int index) {
  // @@protoc_insertion_point(field_mutable:kf.EventSpiderGiagram.someday_count)
  return someday_count_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kf::OneDayEventCount >*
EventSpiderGiagram::mutable_someday_count() {
  // @@protoc_insertion_point(field_mutable_list:kf.EventSpiderGiagram.someday_count)
  return &someday_count_;
}
inline const ::kf::OneDayEventCount& EventSpiderGiagram::someday_count(int index) const {
  // @@protoc_insertion_point(field_get:kf.EventSpiderGiagram.someday_count)
  return someday_count_.Get(index);
}
inline ::kf::OneDayEventCount* EventSpiderGiagram::add_someday_count() {
  // @@protoc_insertion_point(field_add:kf.EventSpiderGiagram.someday_count)
  return someday_count_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kf::OneDayEventCount >&
EventSpiderGiagram::someday_count() const {
  // @@protoc_insertion_point(field_list:kf.EventSpiderGiagram.someday_count)
  return someday_count_;
}

// -------------------------------------------------------------------

// TodayAlarmEventCount

// required int32 ab_count = 1;
inline bool TodayAlarmEventCount::has_ab_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TodayAlarmEventCount::set_has_ab_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TodayAlarmEventCount::clear_has_ab_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TodayAlarmEventCount::clear_ab_count() {
  ab_count_ = 0;
  clear_has_ab_count();
}
inline ::google::protobuf::int32 TodayAlarmEventCount::ab_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayAlarmEventCount.ab_count)
  return ab_count_;
}
inline void TodayAlarmEventCount::set_ab_count(::google::protobuf::int32 value) {
  set_has_ab_count();
  ab_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayAlarmEventCount.ab_count)
}

// required int32 intrude_count = 2;
inline bool TodayAlarmEventCount::has_intrude_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TodayAlarmEventCount::set_has_intrude_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TodayAlarmEventCount::clear_has_intrude_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TodayAlarmEventCount::clear_intrude_count() {
  intrude_count_ = 0;
  clear_has_intrude_count();
}
inline ::google::protobuf::int32 TodayAlarmEventCount::intrude_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayAlarmEventCount.intrude_count)
  return intrude_count_;
}
inline void TodayAlarmEventCount::set_intrude_count(::google::protobuf::int32 value) {
  set_has_intrude_count();
  intrude_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayAlarmEventCount.intrude_count)
}

// required int32 blacklist_count = 3;
inline bool TodayAlarmEventCount::has_blacklist_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TodayAlarmEventCount::set_has_blacklist_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TodayAlarmEventCount::clear_has_blacklist_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TodayAlarmEventCount::clear_blacklist_count() {
  blacklist_count_ = 0;
  clear_has_blacklist_count();
}
inline ::google::protobuf::int32 TodayAlarmEventCount::blacklist_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayAlarmEventCount.blacklist_count)
  return blacklist_count_;
}
inline void TodayAlarmEventCount::set_blacklist_count(::google::protobuf::int32 value) {
  set_has_blacklist_count();
  blacklist_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayAlarmEventCount.blacklist_count)
}

// -------------------------------------------------------------------

// PieCharData

// required string camera_pos = 1;
inline bool PieCharData::has_camera_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PieCharData::set_has_camera_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PieCharData::clear_has_camera_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PieCharData::clear_camera_pos() {
  camera_pos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_pos();
}
inline const ::std::string& PieCharData::camera_pos() const {
  // @@protoc_insertion_point(field_get:kf.PieCharData.camera_pos)
  return camera_pos_.GetNoArena();
}
inline void PieCharData::set_camera_pos(const ::std::string& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.PieCharData.camera_pos)
}
#if LANG_CXX11
inline void PieCharData::set_camera_pos(::std::string&& value) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.PieCharData.camera_pos)
}
#endif
inline void PieCharData::set_camera_pos(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.PieCharData.camera_pos)
}
inline void PieCharData::set_camera_pos(const char* value, size_t size) {
  set_has_camera_pos();
  camera_pos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.PieCharData.camera_pos)
}
inline ::std::string* PieCharData::mutable_camera_pos() {
  set_has_camera_pos();
  // @@protoc_insertion_point(field_mutable:kf.PieCharData.camera_pos)
  return camera_pos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PieCharData::release_camera_pos() {
  // @@protoc_insertion_point(field_release:kf.PieCharData.camera_pos)
  if (!has_camera_pos()) {
    return NULL;
  }
  clear_has_camera_pos();
  return camera_pos_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PieCharData::set_allocated_camera_pos(::std::string* camera_pos) {
  if (camera_pos != NULL) {
    set_has_camera_pos();
  } else {
    clear_has_camera_pos();
  }
  camera_pos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_pos);
  // @@protoc_insertion_point(field_set_allocated:kf.PieCharData.camera_pos)
}

// required int32 cost_time = 2;
inline bool PieCharData::has_cost_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PieCharData::set_has_cost_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PieCharData::clear_has_cost_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PieCharData::clear_cost_time() {
  cost_time_ = 0;
  clear_has_cost_time();
}
inline ::google::protobuf::int32 PieCharData::cost_time() const {
  // @@protoc_insertion_point(field_get:kf.PieCharData.cost_time)
  return cost_time_;
}
inline void PieCharData::set_cost_time(::google::protobuf::int32 value) {
  set_has_cost_time();
  cost_time_ = value;
  // @@protoc_insertion_point(field_set:kf.PieCharData.cost_time)
}

// -------------------------------------------------------------------

// PieChart

// repeated .kf.PieCharData pie_chart_data = 1;
inline int PieChart::pie_chart_data_size() const {
  return pie_chart_data_.size();
}
inline void PieChart::clear_pie_chart_data() {
  pie_chart_data_.Clear();
}
inline ::kf::PieCharData* PieChart::mutable_pie_chart_data(int index) {
  // @@protoc_insertion_point(field_mutable:kf.PieChart.pie_chart_data)
  return pie_chart_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kf::PieCharData >*
PieChart::mutable_pie_chart_data() {
  // @@protoc_insertion_point(field_mutable_list:kf.PieChart.pie_chart_data)
  return &pie_chart_data_;
}
inline const ::kf::PieCharData& PieChart::pie_chart_data(int index) const {
  // @@protoc_insertion_point(field_get:kf.PieChart.pie_chart_data)
  return pie_chart_data_.Get(index);
}
inline ::kf::PieCharData* PieChart::add_pie_chart_data() {
  // @@protoc_insertion_point(field_add:kf.PieChart.pie_chart_data)
  return pie_chart_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kf::PieCharData >&
PieChart::pie_chart_data() const {
  // @@protoc_insertion_point(field_list:kf.PieChart.pie_chart_data)
  return pie_chart_data_;
}

// -------------------------------------------------------------------

// TodayFaceCount

// required int32 snap_count = 1;
inline bool TodayFaceCount::has_snap_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TodayFaceCount::set_has_snap_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TodayFaceCount::clear_has_snap_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TodayFaceCount::clear_snap_count() {
  snap_count_ = 0;
  clear_has_snap_count();
}
inline ::google::protobuf::int32 TodayFaceCount::snap_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayFaceCount.snap_count)
  return snap_count_;
}
inline void TodayFaceCount::set_snap_count(::google::protobuf::int32 value) {
  set_has_snap_count();
  snap_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayFaceCount.snap_count)
}

// required int32 blacklist_count = 2;
inline bool TodayFaceCount::has_blacklist_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TodayFaceCount::set_has_blacklist_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TodayFaceCount::clear_has_blacklist_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TodayFaceCount::clear_blacklist_count() {
  blacklist_count_ = 0;
  clear_has_blacklist_count();
}
inline ::google::protobuf::int32 TodayFaceCount::blacklist_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayFaceCount.blacklist_count)
  return blacklist_count_;
}
inline void TodayFaceCount::set_blacklist_count(::google::protobuf::int32 value) {
  set_has_blacklist_count();
  blacklist_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayFaceCount.blacklist_count)
}

// required int32 served_count = 3;
inline bool TodayFaceCount::has_served_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TodayFaceCount::set_has_served_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TodayFaceCount::clear_has_served_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TodayFaceCount::clear_served_count() {
  served_count_ = 0;
  clear_has_served_count();
}
inline ::google::protobuf::int32 TodayFaceCount::served_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayFaceCount.served_count)
  return served_count_;
}
inline void TodayFaceCount::set_served_count(::google::protobuf::int32 value) {
  set_has_served_count();
  served_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayFaceCount.served_count)
}

// required int32 blacklist_alarm_count = 4;
inline bool TodayFaceCount::has_blacklist_alarm_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TodayFaceCount::set_has_blacklist_alarm_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TodayFaceCount::clear_has_blacklist_alarm_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TodayFaceCount::clear_blacklist_alarm_count() {
  blacklist_alarm_count_ = 0;
  clear_has_blacklist_alarm_count();
}
inline ::google::protobuf::int32 TodayFaceCount::blacklist_alarm_count() const {
  // @@protoc_insertion_point(field_get:kf.TodayFaceCount.blacklist_alarm_count)
  return blacklist_alarm_count_;
}
inline void TodayFaceCount::set_blacklist_alarm_count(::google::protobuf::int32 value) {
  set_has_blacklist_alarm_count();
  blacklist_alarm_count_ = value;
  // @@protoc_insertion_point(field_set:kf.TodayFaceCount.blacklist_alarm_count)
}

// -------------------------------------------------------------------

// SnapAreaGiagram

// repeated int32 snap_count_point = 1;
inline int SnapAreaGiagram::snap_count_point_size() const {
  return snap_count_point_.size();
}
inline void SnapAreaGiagram::clear_snap_count_point() {
  snap_count_point_.Clear();
}
inline ::google::protobuf::int32 SnapAreaGiagram::snap_count_point(int index) const {
  // @@protoc_insertion_point(field_get:kf.SnapAreaGiagram.snap_count_point)
  return snap_count_point_.Get(index);
}
inline void SnapAreaGiagram::set_snap_count_point(int index, ::google::protobuf::int32 value) {
  snap_count_point_.Set(index, value);
  // @@protoc_insertion_point(field_set:kf.SnapAreaGiagram.snap_count_point)
}
inline void SnapAreaGiagram::add_snap_count_point(::google::protobuf::int32 value) {
  snap_count_point_.Add(value);
  // @@protoc_insertion_point(field_add:kf.SnapAreaGiagram.snap_count_point)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SnapAreaGiagram::snap_count_point() const {
  // @@protoc_insertion_point(field_list:kf.SnapAreaGiagram.snap_count_point)
  return snap_count_point_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SnapAreaGiagram::mutable_snap_count_point() {
  // @@protoc_insertion_point(field_mutable_list:kf.SnapAreaGiagram.snap_count_point)
  return &snap_count_point_;
}

// -------------------------------------------------------------------

// Tree

// required int32 status = 1;
inline bool Tree::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tree::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tree::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tree::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Tree::status() const {
  // @@protoc_insertion_point(field_get:kf.Tree.status)
  return status_;
}
inline void Tree::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:kf.Tree.status)
}

// required string oid = 2;
inline bool Tree::has_oid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tree::set_has_oid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tree::clear_has_oid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tree::clear_oid() {
  oid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oid();
}
inline const ::std::string& Tree::oid() const {
  // @@protoc_insertion_point(field_get:kf.Tree.oid)
  return oid_.GetNoArena();
}
inline void Tree::set_oid(const ::std::string& value) {
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.Tree.oid)
}
#if LANG_CXX11
inline void Tree::set_oid(::std::string&& value) {
  set_has_oid();
  oid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.Tree.oid)
}
#endif
inline void Tree::set_oid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.Tree.oid)
}
inline void Tree::set_oid(const char* value, size_t size) {
  set_has_oid();
  oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.Tree.oid)
}
inline ::std::string* Tree::mutable_oid() {
  set_has_oid();
  // @@protoc_insertion_point(field_mutable:kf.Tree.oid)
  return oid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tree::release_oid() {
  // @@protoc_insertion_point(field_release:kf.Tree.oid)
  if (!has_oid()) {
    return NULL;
  }
  clear_has_oid();
  return oid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tree::set_allocated_oid(::std::string* oid) {
  if (oid != NULL) {
    set_has_oid();
  } else {
    clear_has_oid();
  }
  oid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oid);
  // @@protoc_insertion_point(field_set_allocated:kf.Tree.oid)
}

// required string msg = 3;
inline bool Tree::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tree::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tree::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tree::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
inline const ::std::string& Tree::msg() const {
  // @@protoc_insertion_point(field_get:kf.Tree.msg)
  return msg_.GetNoArena();
}
inline void Tree::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kf.Tree.msg)
}
#if LANG_CXX11
inline void Tree::set_msg(::std::string&& value) {
  set_has_msg();
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kf.Tree.msg)
}
#endif
inline void Tree::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kf.Tree.msg)
}
inline void Tree::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kf.Tree.msg)
}
inline ::std::string* Tree::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:kf.Tree.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tree::release_msg() {
  // @@protoc_insertion_point(field_release:kf.Tree.msg)
  if (!has_msg()) {
    return NULL;
  }
  clear_has_msg();
  return msg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tree::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:kf.Tree.msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_face_2eproto
