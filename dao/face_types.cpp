/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "face_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kAreaTypeValues[] = {
  AreaType::FORBIDDENZONE,
  AreaType::ABDOOR
};
const char* _kAreaTypeNames[] = {
  "FORBIDDENZONE",
  "ABDOOR"
};
const std::map<int, const char*> _AreaType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kAreaTypeValues, _kAreaTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const AreaType::type& val) {
  std::map<int, const char*>::const_iterator it = _AreaType_VALUES_TO_NAMES.find(val);
  if (it != _AreaType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


FaceInfo::~FaceInfo() throw() {
}


void FaceInfo::__set_sno(const int32_t val) {
  this->sno = val;
}

void FaceInfo::__set_sname(const std::string& val) {
  this->sname = val;
}

void FaceInfo::__set_ssex(const std::string& val) {
  this->ssex = val;
}

void FaceInfo::__set_sage(const int16_t val) {
  this->sage = val;
}

void FaceInfo::__set_faceimg(const std::string& val) {
  this->faceimg = val;
}
std::ostream& operator<<(std::ostream& out, const FaceInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FaceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sno);
          this->__isset.sno = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sname);
          this->__isset.sname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ssex);
          this->__isset.ssex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sage);
          this->__isset.sage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->faceimg);
          this->__isset.faceimg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceInfo");

  xfer += oprot->writeFieldBegin("sno", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->sno);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssex", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ssex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sage", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("faceimg", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->faceimg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FaceInfo &a, FaceInfo &b) {
  using ::std::swap;
  swap(a.sno, b.sno);
  swap(a.sname, b.sname);
  swap(a.ssex, b.ssex);
  swap(a.sage, b.sage);
  swap(a.faceimg, b.faceimg);
  swap(a.__isset, b.__isset);
}

FaceInfo::FaceInfo(const FaceInfo& other0) {
  sno = other0.sno;
  sname = other0.sname;
  ssex = other0.ssex;
  sage = other0.sage;
  faceimg = other0.faceimg;
  __isset = other0.__isset;
}
FaceInfo& FaceInfo::operator=(const FaceInfo& other1) {
  sno = other1.sno;
  sname = other1.sname;
  ssex = other1.ssex;
  sage = other1.sage;
  faceimg = other1.faceimg;
  __isset = other1.__isset;
  return *this;
}
void FaceInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FaceInfo(";
  out << "sno=" << to_string(sno);
  out << ", " << "sname=" << to_string(sname);
  out << ", " << "ssex=" << to_string(ssex);
  out << ", " << "sage=" << to_string(sage);
  out << ", " << "faceimg=" << to_string(faceimg);
  out << ")";
}


ScenePic::~ScenePic() throw() {
}


void ScenePic::__set_scene_img(const std::string& val) {
  this->scene_img = val;
}
std::ostream& operator<<(std::ostream& out, const ScenePic& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScenePic::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->scene_img);
          this->__isset.scene_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScenePic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScenePic");

  xfer += oprot->writeFieldBegin("scene_img", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->scene_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScenePic &a, ScenePic &b) {
  using ::std::swap;
  swap(a.scene_img, b.scene_img);
  swap(a.__isset, b.__isset);
}

ScenePic::ScenePic(const ScenePic& other2) {
  scene_img = other2.scene_img;
  __isset = other2.__isset;
}
ScenePic& ScenePic::operator=(const ScenePic& other3) {
  scene_img = other3.scene_img;
  __isset = other3.__isset;
  return *this;
}
void ScenePic::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScenePic(";
  out << "scene_img=" << to_string(scene_img);
  out << ")";
}


SnapFaceHis::~SnapFaceHis() throw() {
}


void SnapFaceHis::__set_oid(const std::string& val) {
  this->oid = val;
}

void SnapFaceHis::__set_cameraid(const std::string& val) {
  this->cameraid = val;
}

void SnapFaceHis::__set_camera_pos(const std::string& val) {
  this->camera_pos = val;
}

void SnapFaceHis::__set_faceimg(const std::string& val) {
  this->faceimg = val;
}

void SnapFaceHis::__set_time(const int64_t val) {
  this->time = val;
}
std::ostream& operator<<(std::ostream& out, const SnapFaceHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnapFaceHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cameraid);
          this->__isset.cameraid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_pos);
          this->__isset.camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->faceimg);
          this->__isset.faceimg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnapFaceHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnapFaceHis");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cameraid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cameraid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_pos", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("faceimg", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->faceimg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnapFaceHis &a, SnapFaceHis &b) {
  using ::std::swap;
  swap(a.oid, b.oid);
  swap(a.cameraid, b.cameraid);
  swap(a.camera_pos, b.camera_pos);
  swap(a.faceimg, b.faceimg);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

SnapFaceHis::SnapFaceHis(const SnapFaceHis& other4) {
  oid = other4.oid;
  cameraid = other4.cameraid;
  camera_pos = other4.camera_pos;
  faceimg = other4.faceimg;
  time = other4.time;
  __isset = other4.__isset;
}
SnapFaceHis& SnapFaceHis::operator=(const SnapFaceHis& other5) {
  oid = other5.oid;
  cameraid = other5.cameraid;
  camera_pos = other5.camera_pos;
  faceimg = other5.faceimg;
  time = other5.time;
  __isset = other5.__isset;
  return *this;
}
void SnapFaceHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnapFaceHis(";
  out << "oid=" << to_string(oid);
  out << ", " << "cameraid=" << to_string(cameraid);
  out << ", " << "camera_pos=" << to_string(camera_pos);
  out << ", " << "faceimg=" << to_string(faceimg);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


PagedSnapFaceHis::~PagedSnapFaceHis() throw() {
}


void PagedSnapFaceHis::__set_total_page(const int32_t val) {
  this->total_page = val;
}

void PagedSnapFaceHis::__set_total_count(const int32_t val) {
  this->total_count = val;
}

void PagedSnapFaceHis::__set_snap_face_his(const std::vector<SnapFaceHis> & val) {
  this->snap_face_his = val;
}
std::ostream& operator<<(std::ostream& out, const PagedSnapFaceHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PagedSnapFaceHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_page);
          this->__isset.total_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_count);
          this->__isset.total_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snap_face_his.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->snap_face_his.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->snap_face_his[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snap_face_his = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PagedSnapFaceHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PagedSnapFaceHis");

  xfer += oprot->writeFieldBegin("total_page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->total_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snap_face_his", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snap_face_his.size()));
    std::vector<SnapFaceHis> ::const_iterator _iter11;
    for (_iter11 = this->snap_face_his.begin(); _iter11 != this->snap_face_his.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PagedSnapFaceHis &a, PagedSnapFaceHis &b) {
  using ::std::swap;
  swap(a.total_page, b.total_page);
  swap(a.total_count, b.total_count);
  swap(a.snap_face_his, b.snap_face_his);
  swap(a.__isset, b.__isset);
}

PagedSnapFaceHis::PagedSnapFaceHis(const PagedSnapFaceHis& other12) {
  total_page = other12.total_page;
  total_count = other12.total_count;
  snap_face_his = other12.snap_face_his;
  __isset = other12.__isset;
}
PagedSnapFaceHis& PagedSnapFaceHis::operator=(const PagedSnapFaceHis& other13) {
  total_page = other13.total_page;
  total_count = other13.total_count;
  snap_face_his = other13.snap_face_his;
  __isset = other13.__isset;
  return *this;
}
void PagedSnapFaceHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PagedSnapFaceHis(";
  out << "total_page=" << to_string(total_page);
  out << ", " << "total_count=" << to_string(total_count);
  out << ", " << "snap_face_his=" << to_string(snap_face_his);
  out << ")";
}


StatisTask::~StatisTask() throw() {
}


void StatisTask::__set_start_camera_id(const std::string& val) {
  this->start_camera_id = val;
}

void StatisTask::__set_end_camera_id(const std::string& val) {
  this->end_camera_id = val;
}

void StatisTask::__set_start_camera_pos(const std::string& val) {
  this->start_camera_pos = val;
}

void StatisTask::__set_end_camera_pos(const std::string& val) {
  this->end_camera_pos = val;
}
std::ostream& operator<<(std::ostream& out, const StatisTask& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StatisTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_camera_id);
          this->__isset.start_camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_camera_id);
          this->__isset.end_camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_camera_pos);
          this->__isset.start_camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_camera_pos);
          this->__isset.end_camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StatisTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StatisTask");

  xfer += oprot->writeFieldBegin("start_camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start_camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_camera_pos", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->start_camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_camera_pos", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->end_camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StatisTask &a, StatisTask &b) {
  using ::std::swap;
  swap(a.start_camera_id, b.start_camera_id);
  swap(a.end_camera_id, b.end_camera_id);
  swap(a.start_camera_pos, b.start_camera_pos);
  swap(a.end_camera_pos, b.end_camera_pos);
  swap(a.__isset, b.__isset);
}

StatisTask::StatisTask(const StatisTask& other14) {
  start_camera_id = other14.start_camera_id;
  end_camera_id = other14.end_camera_id;
  start_camera_pos = other14.start_camera_pos;
  end_camera_pos = other14.end_camera_pos;
  __isset = other14.__isset;
}
StatisTask& StatisTask::operator=(const StatisTask& other15) {
  start_camera_id = other15.start_camera_id;
  end_camera_id = other15.end_camera_id;
  start_camera_pos = other15.start_camera_pos;
  end_camera_pos = other15.end_camera_pos;
  __isset = other15.__isset;
  return *this;
}
void StatisTask::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StatisTask(";
  out << "start_camera_id=" << to_string(start_camera_id);
  out << ", " << "end_camera_id=" << to_string(end_camera_id);
  out << ", " << "start_camera_pos=" << to_string(start_camera_pos);
  out << ", " << "end_camera_pos=" << to_string(end_camera_pos);
  out << ")";
}


FaceStatistics::~FaceStatistics() throw() {
}


void FaceStatistics::__set_snap_total(const int32_t val) {
  this->snap_total = val;
}

void FaceStatistics::__set_today_total(const int32_t val) {
  this->today_total = val;
}
std::ostream& operator<<(std::ostream& out, const FaceStatistics& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FaceStatistics::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->snap_total);
          this->__isset.snap_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->today_total);
          this->__isset.today_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceStatistics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceStatistics");

  xfer += oprot->writeFieldBegin("snap_total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->snap_total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("today_total", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->today_total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FaceStatistics &a, FaceStatistics &b) {
  using ::std::swap;
  swap(a.snap_total, b.snap_total);
  swap(a.today_total, b.today_total);
  swap(a.__isset, b.__isset);
}

FaceStatistics::FaceStatistics(const FaceStatistics& other16) {
  snap_total = other16.snap_total;
  today_total = other16.today_total;
  __isset = other16.__isset;
}
FaceStatistics& FaceStatistics::operator=(const FaceStatistics& other17) {
  snap_total = other17.snap_total;
  today_total = other17.today_total;
  __isset = other17.__isset;
  return *this;
}
void FaceStatistics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FaceStatistics(";
  out << "snap_total=" << to_string(snap_total);
  out << ", " << "today_total=" << to_string(today_total);
  out << ")";
}


Point::~Point() throw() {
}


void Point::__set_x(const int32_t val) {
  this->x = val;
}

void Point::__set_y(const int32_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const Point& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Point::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Point::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Point");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Point &a, Point &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

Point::Point(const Point& other18) {
  x = other18.x;
  y = other18.y;
  __isset = other18.__isset;
}
Point& Point::operator=(const Point& other19) {
  x = other19.x;
  y = other19.y;
  __isset = other19.__isset;
  return *this;
}
void Point::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Point(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


AlarmHis::~AlarmHis() throw() {
}


void AlarmHis::__set_oid(const std::string& val) {
  this->oid = val;
}

void AlarmHis::__set_camera_id(const std::string& val) {
  this->camera_id = val;
}

void AlarmHis::__set_camera_pos(const std::string& val) {
  this->camera_pos = val;
}

void AlarmHis::__set_alarm_type(const std::string& val) {
  this->alarm_type = val;
}

void AlarmHis::__set_alarm_img(const std::string& val) {
  this->alarm_img = val;
}

void AlarmHis::__set_time(const int64_t val) {
  this->time = val;
}
std::ostream& operator<<(std::ostream& out, const AlarmHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlarmHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_pos);
          this->__isset.camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alarm_type);
          this->__isset.alarm_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->alarm_img);
          this->__isset.alarm_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlarmHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlarmHis");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_pos", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alarm_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->alarm_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alarm_img", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->alarm_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlarmHis &a, AlarmHis &b) {
  using ::std::swap;
  swap(a.oid, b.oid);
  swap(a.camera_id, b.camera_id);
  swap(a.camera_pos, b.camera_pos);
  swap(a.alarm_type, b.alarm_type);
  swap(a.alarm_img, b.alarm_img);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

AlarmHis::AlarmHis(const AlarmHis& other20) {
  oid = other20.oid;
  camera_id = other20.camera_id;
  camera_pos = other20.camera_pos;
  alarm_type = other20.alarm_type;
  alarm_img = other20.alarm_img;
  time = other20.time;
  __isset = other20.__isset;
}
AlarmHis& AlarmHis::operator=(const AlarmHis& other21) {
  oid = other21.oid;
  camera_id = other21.camera_id;
  camera_pos = other21.camera_pos;
  alarm_type = other21.alarm_type;
  alarm_img = other21.alarm_img;
  time = other21.time;
  __isset = other21.__isset;
  return *this;
}
void AlarmHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlarmHis(";
  out << "oid=" << to_string(oid);
  out << ", " << "camera_id=" << to_string(camera_id);
  out << ", " << "camera_pos=" << to_string(camera_pos);
  out << ", " << "alarm_type=" << to_string(alarm_type);
  out << ", " << "alarm_img=" << to_string(alarm_img);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


PagedAlarmHis::~PagedAlarmHis() throw() {
}


void PagedAlarmHis::__set_total_page(const int32_t val) {
  this->total_page = val;
}

void PagedAlarmHis::__set_total_count(const int32_t val) {
  this->total_count = val;
}

void PagedAlarmHis::__set_alarm_his(const std::vector<AlarmHis> & val) {
  this->alarm_his = val;
}
std::ostream& operator<<(std::ostream& out, const PagedAlarmHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PagedAlarmHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_page);
          this->__isset.total_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_count);
          this->__isset.total_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->alarm_his.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->alarm_his.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->alarm_his[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.alarm_his = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PagedAlarmHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PagedAlarmHis");

  xfer += oprot->writeFieldBegin("total_page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->total_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alarm_his", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->alarm_his.size()));
    std::vector<AlarmHis> ::const_iterator _iter27;
    for (_iter27 = this->alarm_his.begin(); _iter27 != this->alarm_his.end(); ++_iter27)
    {
      xfer += (*_iter27).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PagedAlarmHis &a, PagedAlarmHis &b) {
  using ::std::swap;
  swap(a.total_page, b.total_page);
  swap(a.total_count, b.total_count);
  swap(a.alarm_his, b.alarm_his);
  swap(a.__isset, b.__isset);
}

PagedAlarmHis::PagedAlarmHis(const PagedAlarmHis& other28) {
  total_page = other28.total_page;
  total_count = other28.total_count;
  alarm_his = other28.alarm_his;
  __isset = other28.__isset;
}
PagedAlarmHis& PagedAlarmHis::operator=(const PagedAlarmHis& other29) {
  total_page = other29.total_page;
  total_count = other29.total_count;
  alarm_his = other29.alarm_his;
  __isset = other29.__isset;
  return *this;
}
void PagedAlarmHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PagedAlarmHis(";
  out << "total_page=" << to_string(total_page);
  out << ", " << "total_count=" << to_string(total_count);
  out << ", " << "alarm_his=" << to_string(alarm_his);
  out << ")";
}


Area::~Area() throw() {
}


void Area::__set_points(const std::vector<Point> & val) {
  this->points = val;
}

void Area::__set_area_type(const AreaType::type val) {
  this->area_type = val;
}
std::ostream& operator<<(std::ostream& out, const Area& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Area::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->points.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += this->points[_i34].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast35;
          xfer += iprot->readI32(ecast35);
          this->area_type = (AreaType::type)ecast35;
          this->__isset.area_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Area::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Area");

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<Point> ::const_iterator _iter36;
    for (_iter36 = this->points.begin(); _iter36 != this->points.end(); ++_iter36)
    {
      xfer += (*_iter36).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("area_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->area_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Area &a, Area &b) {
  using ::std::swap;
  swap(a.points, b.points);
  swap(a.area_type, b.area_type);
  swap(a.__isset, b.__isset);
}

Area::Area(const Area& other37) {
  points = other37.points;
  area_type = other37.area_type;
  __isset = other37.__isset;
}
Area& Area::operator=(const Area& other38) {
  points = other38.points;
  area_type = other38.area_type;
  __isset = other38.__isset;
  return *this;
}
void Area::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Area(";
  out << "points=" << to_string(points);
  out << ", " << "area_type=" << to_string(area_type);
  out << ")";
}


SearchFace::~SearchFace() throw() {
}


void SearchFace::__set_oid(const std::string& val) {
  this->oid = val;
}

void SearchFace::__set_camera_id(const std::string& val) {
  this->camera_id = val;
}

void SearchFace::__set_camera_pos(const std::string& val) {
  this->camera_pos = val;
}

void SearchFace::__set_score(const double val) {
  this->score = val;
}

void SearchFace::__set_face_img(const std::string& val) {
  this->face_img = val;
}

void SearchFace::__set_time(const int64_t val) {
  this->time = val;
}
std::ostream& operator<<(std::ostream& out, const SearchFace& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SearchFace::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_pos);
          this->__isset.camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->score);
          this->__isset.score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->face_img);
          this->__isset.face_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SearchFace::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SearchFace");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_pos", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->score);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->face_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SearchFace &a, SearchFace &b) {
  using ::std::swap;
  swap(a.oid, b.oid);
  swap(a.camera_id, b.camera_id);
  swap(a.camera_pos, b.camera_pos);
  swap(a.score, b.score);
  swap(a.face_img, b.face_img);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

SearchFace::SearchFace(const SearchFace& other39) {
  oid = other39.oid;
  camera_id = other39.camera_id;
  camera_pos = other39.camera_pos;
  score = other39.score;
  face_img = other39.face_img;
  time = other39.time;
  __isset = other39.__isset;
}
SearchFace& SearchFace::operator=(const SearchFace& other40) {
  oid = other40.oid;
  camera_id = other40.camera_id;
  camera_pos = other40.camera_pos;
  score = other40.score;
  face_img = other40.face_img;
  time = other40.time;
  __isset = other40.__isset;
  return *this;
}
void SearchFace::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SearchFace(";
  out << "oid=" << to_string(oid);
  out << ", " << "camera_id=" << to_string(camera_id);
  out << ", " << "camera_pos=" << to_string(camera_pos);
  out << ", " << "score=" << to_string(score);
  out << ", " << "face_img=" << to_string(face_img);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


FaceLink::~FaceLink() throw() {
}


void FaceLink::__set_node_oids(const std::vector<std::string> & val) {
  this->node_oids = val;
}

void FaceLink::__set_link_oids(const std::vector<std::vector<std::string> > & val) {
  this->link_oids = val;
}
std::ostream& operator<<(std::ostream& out, const FaceLink& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FaceLink::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node_oids.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->node_oids.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += iprot->readString(this->node_oids[_i45]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node_oids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->link_oids.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->link_oids.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              {
                this->link_oids[_i50].clear();
                uint32_t _size51;
                ::apache::thrift::protocol::TType _etype54;
                xfer += iprot->readListBegin(_etype54, _size51);
                this->link_oids[_i50].resize(_size51);
                uint32_t _i55;
                for (_i55 = 0; _i55 < _size51; ++_i55)
                {
                  xfer += iprot->readString(this->link_oids[_i50][_i55]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.link_oids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceLink::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceLink");

  xfer += oprot->writeFieldBegin("node_oids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->node_oids.size()));
    std::vector<std::string> ::const_iterator _iter56;
    for (_iter56 = this->node_oids.begin(); _iter56 != this->node_oids.end(); ++_iter56)
    {
      xfer += oprot->writeString((*_iter56));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("link_oids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->link_oids.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter57;
    for (_iter57 = this->link_oids.begin(); _iter57 != this->link_oids.end(); ++_iter57)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter57).size()));
        std::vector<std::string> ::const_iterator _iter58;
        for (_iter58 = (*_iter57).begin(); _iter58 != (*_iter57).end(); ++_iter58)
        {
          xfer += oprot->writeString((*_iter58));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FaceLink &a, FaceLink &b) {
  using ::std::swap;
  swap(a.node_oids, b.node_oids);
  swap(a.link_oids, b.link_oids);
  swap(a.__isset, b.__isset);
}

FaceLink::FaceLink(const FaceLink& other59) {
  node_oids = other59.node_oids;
  link_oids = other59.link_oids;
  __isset = other59.__isset;
}
FaceLink& FaceLink::operator=(const FaceLink& other60) {
  node_oids = other60.node_oids;
  link_oids = other60.link_oids;
  __isset = other60.__isset;
  return *this;
}
void FaceLink::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FaceLink(";
  out << "node_oids=" << to_string(node_oids);
  out << ", " << "link_oids=" << to_string(link_oids);
  out << ")";
}


PageSnapFaceHis::~PageSnapFaceHis() throw() {
}


void PageSnapFaceHis::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void PageSnapFaceHis::__set_snap_face_his(const std::vector<SnapFaceHis> & val) {
  this->snap_face_his = val;
}
std::ostream& operator<<(std::ostream& out, const PageSnapFaceHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PageSnapFaceHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snap_face_his.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _etype64;
            xfer += iprot->readListBegin(_etype64, _size61);
            this->snap_face_his.resize(_size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              xfer += this->snap_face_his[_i65].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snap_face_his = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PageSnapFaceHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PageSnapFaceHis");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snap_face_his", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snap_face_his.size()));
    std::vector<SnapFaceHis> ::const_iterator _iter66;
    for (_iter66 = this->snap_face_his.begin(); _iter66 != this->snap_face_his.end(); ++_iter66)
    {
      xfer += (*_iter66).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PageSnapFaceHis &a, PageSnapFaceHis &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.snap_face_his, b.snap_face_his);
  swap(a.__isset, b.__isset);
}

PageSnapFaceHis::PageSnapFaceHis(const PageSnapFaceHis& other67) {
  session_id = other67.session_id;
  snap_face_his = other67.snap_face_his;
  __isset = other67.__isset;
}
PageSnapFaceHis& PageSnapFaceHis::operator=(const PageSnapFaceHis& other68) {
  session_id = other68.session_id;
  snap_face_his = other68.snap_face_his;
  __isset = other68.__isset;
  return *this;
}
void PageSnapFaceHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageSnapFaceHis(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "snap_face_his=" << to_string(snap_face_his);
  out << ")";
}


