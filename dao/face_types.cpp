/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "face_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kAreaTypeValues[] = {
  AreaType::FORBIDDENZONE,
  AreaType::ABDOOR
};
const char* _kAreaTypeNames[] = {
  "FORBIDDENZONE",
  "ABDOOR"
};
const std::map<int, const char*> _AreaType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kAreaTypeValues, _kAreaTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const AreaType::type& val) {
  std::map<int, const char*>::const_iterator it = _AreaType_VALUES_TO_NAMES.find(val);
  if (it != _AreaType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


FaceInfo::~FaceInfo() throw() {
}


void FaceInfo::__set_sno(const int32_t val) {
  this->sno = val;
}

void FaceInfo::__set_sname(const std::string& val) {
  this->sname = val;
}

void FaceInfo::__set_ssex(const std::string& val) {
  this->ssex = val;
}

void FaceInfo::__set_sage(const int16_t val) {
  this->sage = val;
}

void FaceInfo::__set_faceimg(const std::string& val) {
  this->faceimg = val;
}
std::ostream& operator<<(std::ostream& out, const FaceInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FaceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sno);
          this->__isset.sno = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sname);
          this->__isset.sname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ssex);
          this->__isset.ssex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->sage);
          this->__isset.sage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->faceimg);
          this->__isset.faceimg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceInfo");

  xfer += oprot->writeFieldBegin("sno", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->sno);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ssex", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ssex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sage", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->sage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("faceimg", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->faceimg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FaceInfo &a, FaceInfo &b) {
  using ::std::swap;
  swap(a.sno, b.sno);
  swap(a.sname, b.sname);
  swap(a.ssex, b.ssex);
  swap(a.sage, b.sage);
  swap(a.faceimg, b.faceimg);
  swap(a.__isset, b.__isset);
}

FaceInfo::FaceInfo(const FaceInfo& other0) {
  sno = other0.sno;
  sname = other0.sname;
  ssex = other0.ssex;
  sage = other0.sage;
  faceimg = other0.faceimg;
  __isset = other0.__isset;
}
FaceInfo& FaceInfo::operator=(const FaceInfo& other1) {
  sno = other1.sno;
  sname = other1.sname;
  ssex = other1.ssex;
  sage = other1.sage;
  faceimg = other1.faceimg;
  __isset = other1.__isset;
  return *this;
}
void FaceInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FaceInfo(";
  out << "sno=" << to_string(sno);
  out << ", " << "sname=" << to_string(sname);
  out << ", " << "ssex=" << to_string(ssex);
  out << ", " << "sage=" << to_string(sage);
  out << ", " << "faceimg=" << to_string(faceimg);
  out << ")";
}


ScenePic::~ScenePic() throw() {
}


void ScenePic::__set_scene_img(const std::string& val) {
  this->scene_img = val;
}
std::ostream& operator<<(std::ostream& out, const ScenePic& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ScenePic::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->scene_img);
          this->__isset.scene_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ScenePic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ScenePic");

  xfer += oprot->writeFieldBegin("scene_img", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->scene_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ScenePic &a, ScenePic &b) {
  using ::std::swap;
  swap(a.scene_img, b.scene_img);
  swap(a.__isset, b.__isset);
}

ScenePic::ScenePic(const ScenePic& other2) {
  scene_img = other2.scene_img;
  __isset = other2.__isset;
}
ScenePic& ScenePic::operator=(const ScenePic& other3) {
  scene_img = other3.scene_img;
  __isset = other3.__isset;
  return *this;
}
void ScenePic::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ScenePic(";
  out << "scene_img=" << to_string(scene_img);
  out << ")";
}


CameraInfo::~CameraInfo() throw() {
}


void CameraInfo::__set_id(const std::string& val) {
  this->id = val;
}

void CameraInfo::__set_position(const std::string& val) {
  this->position = val;
}

void CameraInfo::__set_rtsp(const std::string& val) {
  this->rtsp = val;
}

void CameraInfo::__set_dvr_ip(const std::string& val) {
  this->dvr_ip = val;
}

void CameraInfo::__set_dvr_port(const int32_t val) {
  this->dvr_port = val;
}

void CameraInfo::__set_dvr_user(const std::string& val) {
  this->dvr_user = val;
}

void CameraInfo::__set_dvr_password(const std::string& val) {
  this->dvr_password = val;
}

void CameraInfo::__set_dvr_channel(const int32_t val) {
  this->dvr_channel = val;
}
std::ostream& operator<<(std::ostream& out, const CameraInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CameraInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rtsp);
          this->__isset.rtsp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dvr_ip);
          this->__isset.dvr_ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dvr_port);
          this->__isset.dvr_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dvr_user);
          this->__isset.dvr_user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dvr_password);
          this->__isset.dvr_password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dvr_channel);
          this->__isset.dvr_channel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CameraInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CameraInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->position);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rtsp", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->rtsp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dvr_ip", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->dvr_ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dvr_port", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->dvr_port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dvr_user", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->dvr_user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dvr_password", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->dvr_password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dvr_channel", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->dvr_channel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CameraInfo &a, CameraInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.position, b.position);
  swap(a.rtsp, b.rtsp);
  swap(a.dvr_ip, b.dvr_ip);
  swap(a.dvr_port, b.dvr_port);
  swap(a.dvr_user, b.dvr_user);
  swap(a.dvr_password, b.dvr_password);
  swap(a.dvr_channel, b.dvr_channel);
  swap(a.__isset, b.__isset);
}

CameraInfo::CameraInfo(const CameraInfo& other4) {
  id = other4.id;
  position = other4.position;
  rtsp = other4.rtsp;
  dvr_ip = other4.dvr_ip;
  dvr_port = other4.dvr_port;
  dvr_user = other4.dvr_user;
  dvr_password = other4.dvr_password;
  dvr_channel = other4.dvr_channel;
  __isset = other4.__isset;
}
CameraInfo& CameraInfo::operator=(const CameraInfo& other5) {
  id = other5.id;
  position = other5.position;
  rtsp = other5.rtsp;
  dvr_ip = other5.dvr_ip;
  dvr_port = other5.dvr_port;
  dvr_user = other5.dvr_user;
  dvr_password = other5.dvr_password;
  dvr_channel = other5.dvr_channel;
  __isset = other5.__isset;
  return *this;
}
void CameraInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CameraInfo(";
  out << "id=" << to_string(id);
  out << ", " << "position=" << to_string(position);
  out << ", " << "rtsp=" << to_string(rtsp);
  out << ", " << "dvr_ip=" << to_string(dvr_ip);
  out << ", " << "dvr_port=" << to_string(dvr_port);
  out << ", " << "dvr_user=" << to_string(dvr_user);
  out << ", " << "dvr_password=" << to_string(dvr_password);
  out << ", " << "dvr_channel=" << to_string(dvr_channel);
  out << ")";
}


SnapFaceHis::~SnapFaceHis() throw() {
}


void SnapFaceHis::__set_oid(const std::string& val) {
  this->oid = val;
}

void SnapFaceHis::__set_cameraid(const std::string& val) {
  this->cameraid = val;
}

void SnapFaceHis::__set_camera_pos(const std::string& val) {
  this->camera_pos = val;
}

void SnapFaceHis::__set_faceimg(const std::string& val) {
  this->faceimg = val;
}

void SnapFaceHis::__set_time(const int64_t val) {
  this->time = val;
}
std::ostream& operator<<(std::ostream& out, const SnapFaceHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnapFaceHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cameraid);
          this->__isset.cameraid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_pos);
          this->__isset.camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->faceimg);
          this->__isset.faceimg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnapFaceHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnapFaceHis");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cameraid", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->cameraid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_pos", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("faceimg", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->faceimg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnapFaceHis &a, SnapFaceHis &b) {
  using ::std::swap;
  swap(a.oid, b.oid);
  swap(a.cameraid, b.cameraid);
  swap(a.camera_pos, b.camera_pos);
  swap(a.faceimg, b.faceimg);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

SnapFaceHis::SnapFaceHis(const SnapFaceHis& other6) {
  oid = other6.oid;
  cameraid = other6.cameraid;
  camera_pos = other6.camera_pos;
  faceimg = other6.faceimg;
  time = other6.time;
  __isset = other6.__isset;
}
SnapFaceHis& SnapFaceHis::operator=(const SnapFaceHis& other7) {
  oid = other7.oid;
  cameraid = other7.cameraid;
  camera_pos = other7.camera_pos;
  faceimg = other7.faceimg;
  time = other7.time;
  __isset = other7.__isset;
  return *this;
}
void SnapFaceHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnapFaceHis(";
  out << "oid=" << to_string(oid);
  out << ", " << "cameraid=" << to_string(cameraid);
  out << ", " << "camera_pos=" << to_string(camera_pos);
  out << ", " << "faceimg=" << to_string(faceimg);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


PagedSnapFaceHis::~PagedSnapFaceHis() throw() {
}


void PagedSnapFaceHis::__set_total_page(const int32_t val) {
  this->total_page = val;
}

void PagedSnapFaceHis::__set_total_count(const int32_t val) {
  this->total_count = val;
}

void PagedSnapFaceHis::__set_snap_face_his(const std::vector<SnapFaceHis> & val) {
  this->snap_face_his = val;
}
std::ostream& operator<<(std::ostream& out, const PagedSnapFaceHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PagedSnapFaceHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_page);
          this->__isset.total_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_count);
          this->__isset.total_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snap_face_his.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->snap_face_his.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->snap_face_his[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snap_face_his = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PagedSnapFaceHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PagedSnapFaceHis");

  xfer += oprot->writeFieldBegin("total_page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->total_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snap_face_his", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snap_face_his.size()));
    std::vector<SnapFaceHis> ::const_iterator _iter13;
    for (_iter13 = this->snap_face_his.begin(); _iter13 != this->snap_face_his.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PagedSnapFaceHis &a, PagedSnapFaceHis &b) {
  using ::std::swap;
  swap(a.total_page, b.total_page);
  swap(a.total_count, b.total_count);
  swap(a.snap_face_his, b.snap_face_his);
  swap(a.__isset, b.__isset);
}

PagedSnapFaceHis::PagedSnapFaceHis(const PagedSnapFaceHis& other14) {
  total_page = other14.total_page;
  total_count = other14.total_count;
  snap_face_his = other14.snap_face_his;
  __isset = other14.__isset;
}
PagedSnapFaceHis& PagedSnapFaceHis::operator=(const PagedSnapFaceHis& other15) {
  total_page = other15.total_page;
  total_count = other15.total_count;
  snap_face_his = other15.snap_face_his;
  __isset = other15.__isset;
  return *this;
}
void PagedSnapFaceHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PagedSnapFaceHis(";
  out << "total_page=" << to_string(total_page);
  out << ", " << "total_count=" << to_string(total_count);
  out << ", " << "snap_face_his=" << to_string(snap_face_his);
  out << ")";
}


StatisTask::~StatisTask() throw() {
}


void StatisTask::__set_start_camera_id(const std::string& val) {
  this->start_camera_id = val;
}

void StatisTask::__set_end_camera_id(const std::string& val) {
  this->end_camera_id = val;
}

void StatisTask::__set_start_camera_pos(const std::string& val) {
  this->start_camera_pos = val;
}

void StatisTask::__set_end_camera_pos(const std::string& val) {
  this->end_camera_pos = val;
}
std::ostream& operator<<(std::ostream& out, const StatisTask& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t StatisTask::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_camera_id);
          this->__isset.start_camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_camera_id);
          this->__isset.end_camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_camera_pos);
          this->__isset.start_camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_camera_pos);
          this->__isset.end_camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StatisTask::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("StatisTask");

  xfer += oprot->writeFieldBegin("start_camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start_camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_camera_pos", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->start_camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_camera_pos", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->end_camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StatisTask &a, StatisTask &b) {
  using ::std::swap;
  swap(a.start_camera_id, b.start_camera_id);
  swap(a.end_camera_id, b.end_camera_id);
  swap(a.start_camera_pos, b.start_camera_pos);
  swap(a.end_camera_pos, b.end_camera_pos);
  swap(a.__isset, b.__isset);
}

StatisTask::StatisTask(const StatisTask& other16) {
  start_camera_id = other16.start_camera_id;
  end_camera_id = other16.end_camera_id;
  start_camera_pos = other16.start_camera_pos;
  end_camera_pos = other16.end_camera_pos;
  __isset = other16.__isset;
}
StatisTask& StatisTask::operator=(const StatisTask& other17) {
  start_camera_id = other17.start_camera_id;
  end_camera_id = other17.end_camera_id;
  start_camera_pos = other17.start_camera_pos;
  end_camera_pos = other17.end_camera_pos;
  __isset = other17.__isset;
  return *this;
}
void StatisTask::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "StatisTask(";
  out << "start_camera_id=" << to_string(start_camera_id);
  out << ", " << "end_camera_id=" << to_string(end_camera_id);
  out << ", " << "start_camera_pos=" << to_string(start_camera_pos);
  out << ", " << "end_camera_pos=" << to_string(end_camera_pos);
  out << ")";
}


FaceStatistics::~FaceStatistics() throw() {
}


void FaceStatistics::__set_snap_total(const int32_t val) {
  this->snap_total = val;
}

void FaceStatistics::__set_today_total(const int32_t val) {
  this->today_total = val;
}
std::ostream& operator<<(std::ostream& out, const FaceStatistics& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FaceStatistics::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->snap_total);
          this->__isset.snap_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->today_total);
          this->__isset.today_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceStatistics::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceStatistics");

  xfer += oprot->writeFieldBegin("snap_total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->snap_total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("today_total", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->today_total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FaceStatistics &a, FaceStatistics &b) {
  using ::std::swap;
  swap(a.snap_total, b.snap_total);
  swap(a.today_total, b.today_total);
  swap(a.__isset, b.__isset);
}

FaceStatistics::FaceStatistics(const FaceStatistics& other18) {
  snap_total = other18.snap_total;
  today_total = other18.today_total;
  __isset = other18.__isset;
}
FaceStatistics& FaceStatistics::operator=(const FaceStatistics& other19) {
  snap_total = other19.snap_total;
  today_total = other19.today_total;
  __isset = other19.__isset;
  return *this;
}
void FaceStatistics::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FaceStatistics(";
  out << "snap_total=" << to_string(snap_total);
  out << ", " << "today_total=" << to_string(today_total);
  out << ")";
}


Point::~Point() throw() {
}


void Point::__set_x(const int32_t val) {
  this->x = val;
}

void Point::__set_y(const int32_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const Point& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Point::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Point::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Point");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Point &a, Point &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

Point::Point(const Point& other20) {
  x = other20.x;
  y = other20.y;
  __isset = other20.__isset;
}
Point& Point::operator=(const Point& other21) {
  x = other21.x;
  y = other21.y;
  __isset = other21.__isset;
  return *this;
}
void Point::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Point(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


AlarmHis::~AlarmHis() throw() {
}


void AlarmHis::__set_oid(const std::string& val) {
  this->oid = val;
}

void AlarmHis::__set_camera_id(const std::string& val) {
  this->camera_id = val;
}

void AlarmHis::__set_camera_pos(const std::string& val) {
  this->camera_pos = val;
}

void AlarmHis::__set_alarm_type(const std::string& val) {
  this->alarm_type = val;
}

void AlarmHis::__set_alarm_img(const std::string& val) {
  this->alarm_img = val;
}

void AlarmHis::__set_time(const int64_t val) {
  this->time = val;
}
std::ostream& operator<<(std::ostream& out, const AlarmHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AlarmHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_pos);
          this->__isset.camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alarm_type);
          this->__isset.alarm_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->alarm_img);
          this->__isset.alarm_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlarmHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlarmHis");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_pos", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alarm_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->alarm_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alarm_img", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->alarm_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AlarmHis &a, AlarmHis &b) {
  using ::std::swap;
  swap(a.oid, b.oid);
  swap(a.camera_id, b.camera_id);
  swap(a.camera_pos, b.camera_pos);
  swap(a.alarm_type, b.alarm_type);
  swap(a.alarm_img, b.alarm_img);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

AlarmHis::AlarmHis(const AlarmHis& other22) {
  oid = other22.oid;
  camera_id = other22.camera_id;
  camera_pos = other22.camera_pos;
  alarm_type = other22.alarm_type;
  alarm_img = other22.alarm_img;
  time = other22.time;
  __isset = other22.__isset;
}
AlarmHis& AlarmHis::operator=(const AlarmHis& other23) {
  oid = other23.oid;
  camera_id = other23.camera_id;
  camera_pos = other23.camera_pos;
  alarm_type = other23.alarm_type;
  alarm_img = other23.alarm_img;
  time = other23.time;
  __isset = other23.__isset;
  return *this;
}
void AlarmHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AlarmHis(";
  out << "oid=" << to_string(oid);
  out << ", " << "camera_id=" << to_string(camera_id);
  out << ", " << "camera_pos=" << to_string(camera_pos);
  out << ", " << "alarm_type=" << to_string(alarm_type);
  out << ", " << "alarm_img=" << to_string(alarm_img);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


PagedAlarmHis::~PagedAlarmHis() throw() {
}


void PagedAlarmHis::__set_total_page(const int32_t val) {
  this->total_page = val;
}

void PagedAlarmHis::__set_total_count(const int32_t val) {
  this->total_count = val;
}

void PagedAlarmHis::__set_alarm_his(const std::vector<AlarmHis> & val) {
  this->alarm_his = val;
}
std::ostream& operator<<(std::ostream& out, const PagedAlarmHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PagedAlarmHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_page);
          this->__isset.total_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total_count);
          this->__isset.total_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->alarm_his.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->alarm_his.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->alarm_his[_i28].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.alarm_his = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PagedAlarmHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PagedAlarmHis");

  xfer += oprot->writeFieldBegin("total_page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total_page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->total_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alarm_his", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->alarm_his.size()));
    std::vector<AlarmHis> ::const_iterator _iter29;
    for (_iter29 = this->alarm_his.begin(); _iter29 != this->alarm_his.end(); ++_iter29)
    {
      xfer += (*_iter29).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PagedAlarmHis &a, PagedAlarmHis &b) {
  using ::std::swap;
  swap(a.total_page, b.total_page);
  swap(a.total_count, b.total_count);
  swap(a.alarm_his, b.alarm_his);
  swap(a.__isset, b.__isset);
}

PagedAlarmHis::PagedAlarmHis(const PagedAlarmHis& other30) {
  total_page = other30.total_page;
  total_count = other30.total_count;
  alarm_his = other30.alarm_his;
  __isset = other30.__isset;
}
PagedAlarmHis& PagedAlarmHis::operator=(const PagedAlarmHis& other31) {
  total_page = other31.total_page;
  total_count = other31.total_count;
  alarm_his = other31.alarm_his;
  __isset = other31.__isset;
  return *this;
}
void PagedAlarmHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PagedAlarmHis(";
  out << "total_page=" << to_string(total_page);
  out << ", " << "total_count=" << to_string(total_count);
  out << ", " << "alarm_his=" << to_string(alarm_his);
  out << ")";
}


Area::~Area() throw() {
}


void Area::__set_points(const std::vector<Point> & val) {
  this->points = val;
}

void Area::__set_area_type(const AreaType::type val) {
  this->area_type = val;
}
std::ostream& operator<<(std::ostream& out, const Area& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Area::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->points.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->points[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast37;
          xfer += iprot->readI32(ecast37);
          this->area_type = (AreaType::type)ecast37;
          this->__isset.area_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Area::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Area");

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<Point> ::const_iterator _iter38;
    for (_iter38 = this->points.begin(); _iter38 != this->points.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("area_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->area_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Area &a, Area &b) {
  using ::std::swap;
  swap(a.points, b.points);
  swap(a.area_type, b.area_type);
  swap(a.__isset, b.__isset);
}

Area::Area(const Area& other39) {
  points = other39.points;
  area_type = other39.area_type;
  __isset = other39.__isset;
}
Area& Area::operator=(const Area& other40) {
  points = other40.points;
  area_type = other40.area_type;
  __isset = other40.__isset;
  return *this;
}
void Area::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Area(";
  out << "points=" << to_string(points);
  out << ", " << "area_type=" << to_string(area_type);
  out << ")";
}


SearchFace::~SearchFace() throw() {
}


void SearchFace::__set_oid(const std::string& val) {
  this->oid = val;
}

void SearchFace::__set_camera_id(const std::string& val) {
  this->camera_id = val;
}

void SearchFace::__set_camera_pos(const std::string& val) {
  this->camera_pos = val;
}

void SearchFace::__set_score(const double val) {
  this->score = val;
}

void SearchFace::__set_face_img(const std::string& val) {
  this->face_img = val;
}

void SearchFace::__set_time(const int64_t val) {
  this->time = val;
}
std::ostream& operator<<(std::ostream& out, const SearchFace& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SearchFace::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_pos);
          this->__isset.camera_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->score);
          this->__isset.score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->face_img);
          this->__isset.face_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SearchFace::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SearchFace");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_pos", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->camera_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->score);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->face_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SearchFace &a, SearchFace &b) {
  using ::std::swap;
  swap(a.oid, b.oid);
  swap(a.camera_id, b.camera_id);
  swap(a.camera_pos, b.camera_pos);
  swap(a.score, b.score);
  swap(a.face_img, b.face_img);
  swap(a.time, b.time);
  swap(a.__isset, b.__isset);
}

SearchFace::SearchFace(const SearchFace& other41) {
  oid = other41.oid;
  camera_id = other41.camera_id;
  camera_pos = other41.camera_pos;
  score = other41.score;
  face_img = other41.face_img;
  time = other41.time;
  __isset = other41.__isset;
}
SearchFace& SearchFace::operator=(const SearchFace& other42) {
  oid = other42.oid;
  camera_id = other42.camera_id;
  camera_pos = other42.camera_pos;
  score = other42.score;
  face_img = other42.face_img;
  time = other42.time;
  __isset = other42.__isset;
  return *this;
}
void SearchFace::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SearchFace(";
  out << "oid=" << to_string(oid);
  out << ", " << "camera_id=" << to_string(camera_id);
  out << ", " << "camera_pos=" << to_string(camera_pos);
  out << ", " << "score=" << to_string(score);
  out << ", " << "face_img=" << to_string(face_img);
  out << ", " << "time=" << to_string(time);
  out << ")";
}


FaceLink::~FaceLink() throw() {
}


void FaceLink::__set_node_oids(const std::vector<std::string> & val) {
  this->node_oids = val;
}

void FaceLink::__set_link_oids(const std::vector<std::vector<std::string> > & val) {
  this->link_oids = val;
}
std::ostream& operator<<(std::ostream& out, const FaceLink& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FaceLink::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->node_oids.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->node_oids.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readString(this->node_oids[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.node_oids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->link_oids.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->link_oids.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              {
                this->link_oids[_i52].clear();
                uint32_t _size53;
                ::apache::thrift::protocol::TType _etype56;
                xfer += iprot->readListBegin(_etype56, _size53);
                this->link_oids[_i52].resize(_size53);
                uint32_t _i57;
                for (_i57 = 0; _i57 < _size53; ++_i57)
                {
                  xfer += iprot->readString(this->link_oids[_i52][_i57]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.link_oids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceLink::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceLink");

  xfer += oprot->writeFieldBegin("node_oids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->node_oids.size()));
    std::vector<std::string> ::const_iterator _iter58;
    for (_iter58 = this->node_oids.begin(); _iter58 != this->node_oids.end(); ++_iter58)
    {
      xfer += oprot->writeString((*_iter58));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("link_oids", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->link_oids.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter59;
    for (_iter59 = this->link_oids.begin(); _iter59 != this->link_oids.end(); ++_iter59)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter59).size()));
        std::vector<std::string> ::const_iterator _iter60;
        for (_iter60 = (*_iter59).begin(); _iter60 != (*_iter59).end(); ++_iter60)
        {
          xfer += oprot->writeString((*_iter60));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FaceLink &a, FaceLink &b) {
  using ::std::swap;
  swap(a.node_oids, b.node_oids);
  swap(a.link_oids, b.link_oids);
  swap(a.__isset, b.__isset);
}

FaceLink::FaceLink(const FaceLink& other61) {
  node_oids = other61.node_oids;
  link_oids = other61.link_oids;
  __isset = other61.__isset;
}
FaceLink& FaceLink::operator=(const FaceLink& other62) {
  node_oids = other62.node_oids;
  link_oids = other62.link_oids;
  __isset = other62.__isset;
  return *this;
}
void FaceLink::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FaceLink(";
  out << "node_oids=" << to_string(node_oids);
  out << ", " << "link_oids=" << to_string(link_oids);
  out << ")";
}


PageSnapFaceHis::~PageSnapFaceHis() throw() {
}


void PageSnapFaceHis::__set_session_id(const std::string& val) {
  this->session_id = val;
}

void PageSnapFaceHis::__set_snap_face_his(const std::vector<SnapFaceHis> & val) {
  this->snap_face_his = val;
}
std::ostream& operator<<(std::ostream& out, const PageSnapFaceHis& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PageSnapFaceHis::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snap_face_his.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->snap_face_his.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += this->snap_face_his[_i67].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snap_face_his = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PageSnapFaceHis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PageSnapFaceHis");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snap_face_his", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snap_face_his.size()));
    std::vector<SnapFaceHis> ::const_iterator _iter68;
    for (_iter68 = this->snap_face_his.begin(); _iter68 != this->snap_face_his.end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PageSnapFaceHis &a, PageSnapFaceHis &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.snap_face_his, b.snap_face_his);
  swap(a.__isset, b.__isset);
}

PageSnapFaceHis::PageSnapFaceHis(const PageSnapFaceHis& other69) {
  session_id = other69.session_id;
  snap_face_his = other69.snap_face_his;
  __isset = other69.__isset;
}
PageSnapFaceHis& PageSnapFaceHis::operator=(const PageSnapFaceHis& other70) {
  session_id = other70.session_id;
  snap_face_his = other70.snap_face_his;
  __isset = other70.__isset;
  return *this;
}
void PageSnapFaceHis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageSnapFaceHis(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "snap_face_his=" << to_string(snap_face_his);
  out << ")";
}


