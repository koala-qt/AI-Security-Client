/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "FaceServ.h"




FaceServ_getFacePic_args::~FaceServ_getFacePic_args() throw() {
}


uint32_t FaceServ_getFacePic_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getFacePic_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getFacePic_args");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getFacePic_pargs::~FaceServ_getFacePic_pargs() throw() {
}


uint32_t FaceServ_getFacePic_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getFacePic_pargs");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getFacePic_result::~FaceServ_getFacePic_result() throw() {
}


uint32_t FaceServ_getFacePic_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getFacePic_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_getFacePic_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRING, 0);
    xfer += oprot->writeBinary(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getFacePic_presult::~FaceServ_getFacePic_presult() throw() {
}


uint32_t FaceServ_getFacePic_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_getScenePic_args::~FaceServ_getScenePic_args() throw() {
}


uint32_t FaceServ_getScenePic_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getScenePic_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getScenePic_args");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getScenePic_pargs::~FaceServ_getScenePic_pargs() throw() {
}


uint32_t FaceServ_getScenePic_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getScenePic_pargs");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getScenePic_result::~FaceServ_getScenePic_result() throw() {
}


uint32_t FaceServ_getScenePic_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getScenePic_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_getScenePic_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getScenePic_presult::~FaceServ_getScenePic_presult() throw() {
}


uint32_t FaceServ_getScenePic_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_getAlarmScenePic_args::~FaceServ_getAlarmScenePic_args() throw() {
}


uint32_t FaceServ_getAlarmScenePic_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getAlarmScenePic_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getAlarmScenePic_args");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAlarmScenePic_pargs::~FaceServ_getAlarmScenePic_pargs() throw() {
}


uint32_t FaceServ_getAlarmScenePic_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getAlarmScenePic_pargs");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAlarmScenePic_result::~FaceServ_getAlarmScenePic_result() throw() {
}


uint32_t FaceServ_getAlarmScenePic_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getAlarmScenePic_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_getAlarmScenePic_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAlarmScenePic_presult::~FaceServ_getAlarmScenePic_presult() throw() {
}


uint32_t FaceServ_getAlarmScenePic_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_getAllCameraInfo_args::~FaceServ_getAllCameraInfo_args() throw() {
}


uint32_t FaceServ_getAllCameraInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getAllCameraInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getAllCameraInfo_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAllCameraInfo_pargs::~FaceServ_getAllCameraInfo_pargs() throw() {
}


uint32_t FaceServ_getAllCameraInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getAllCameraInfo_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAllCameraInfo_result::~FaceServ_getAllCameraInfo_result() throw() {
}


uint32_t FaceServ_getAllCameraInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->success.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += this->success[_i75].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getAllCameraInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_getAllCameraInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<CameraInfo> ::const_iterator _iter76;
      for (_iter76 = this->success.begin(); _iter76 != this->success.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAllCameraInfo_presult::~FaceServ_getAllCameraInfo_presult() throw() {
}


uint32_t FaceServ_getAllCameraInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            (*(this->success)).resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += (*(this->success))[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_snapHistory_args::~FaceServ_snapHistory_args() throw() {
}


uint32_t FaceServ_snapHistory_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cameraid);
          this->__isset.cameraid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_timestap);
          this->__isset.start_timestap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_timstap);
          this->__isset.end_timstap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_snapHistory_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_snapHistory_args");

  xfer += oprot->writeFieldBegin("cameraid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->cameraid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->start_timestap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->end_timstap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_snapHistory_pargs::~FaceServ_snapHistory_pargs() throw() {
}


uint32_t FaceServ_snapHistory_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_snapHistory_pargs");

  xfer += oprot->writeFieldBegin("cameraid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->cameraid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64((*(this->start_timestap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->end_timstap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_snapHistory_result::~FaceServ_snapHistory_result() throw() {
}


uint32_t FaceServ_snapHistory_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->success.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += this->success[_i86].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_snapHistory_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_snapHistory_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<SnapFaceHis> ::const_iterator _iter87;
      for (_iter87 = this->success.begin(); _iter87 != this->success.end(); ++_iter87)
      {
        xfer += (*_iter87).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_snapHistory_presult::~FaceServ_snapHistory_presult() throw() {
}


uint32_t FaceServ_snapHistory_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            (*(this->success)).resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += (*(this->success))[_i92].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_pagenateSnapHistory_args::~FaceServ_pagenateSnapHistory_args() throw() {
}


uint32_t FaceServ_pagenateSnapHistory_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->page);
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cameraid);
          this->__isset.cameraid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_timestap);
          this->__isset.start_timestap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_timstap);
          this->__isset.end_timstap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_pagenateSnapHistory_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_pagenateSnapHistory_args");

  xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cameraid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->cameraid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->start_timestap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->end_timstap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateSnapHistory_pargs::~FaceServ_pagenateSnapHistory_pargs() throw() {
}


uint32_t FaceServ_pagenateSnapHistory_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_pagenateSnapHistory_pargs");

  xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->page)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->num)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cameraid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->cameraid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->start_timestap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->end_timstap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateSnapHistory_result::~FaceServ_pagenateSnapHistory_result() throw() {
}


uint32_t FaceServ_pagenateSnapHistory_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_pagenateSnapHistory_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_pagenateSnapHistory_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateSnapHistory_presult::~FaceServ_pagenateSnapHistory_presult() throw() {
}


uint32_t FaceServ_pagenateSnapHistory_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_pagenateAlarmHistory_args::~FaceServ_pagenateAlarmHistory_args() throw() {
}


uint32_t FaceServ_pagenateAlarmHistory_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->page);
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alarm_type);
          this->__isset.alarm_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_timestap);
          this->__isset.start_timestap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_timstap);
          this->__isset.end_timstap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_pagenateAlarmHistory_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_pagenateAlarmHistory_args");

  xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alarm_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->alarm_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->start_timestap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->end_timstap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateAlarmHistory_pargs::~FaceServ_pagenateAlarmHistory_pargs() throw() {
}


uint32_t FaceServ_pagenateAlarmHistory_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_pagenateAlarmHistory_pargs");

  xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->page)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->num)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alarm_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString((*(this->alarm_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->start_timestap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64((*(this->end_timstap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateAlarmHistory_result::~FaceServ_pagenateAlarmHistory_result() throw() {
}


uint32_t FaceServ_pagenateAlarmHistory_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_pagenateAlarmHistory_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_pagenateAlarmHistory_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateAlarmHistory_presult::~FaceServ_pagenateAlarmHistory_presult() throw() {
}


uint32_t FaceServ_pagenateAlarmHistory_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_getStatisTask_args::~FaceServ_getStatisTask_args() throw() {
}


uint32_t FaceServ_getStatisTask_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getStatisTask_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getStatisTask_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getStatisTask_pargs::~FaceServ_getStatisTask_pargs() throw() {
}


uint32_t FaceServ_getStatisTask_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getStatisTask_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getStatisTask_result::~FaceServ_getStatisTask_result() throw() {
}


uint32_t FaceServ_getStatisTask_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->success.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += this->success[_i97].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getStatisTask_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_getStatisTask_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<StatisTask> ::const_iterator _iter98;
      for (_iter98 = this->success.begin(); _iter98 != this->success.end(); ++_iter98)
      {
        xfer += (*_iter98).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getStatisTask_presult::~FaceServ_getStatisTask_presult() throw() {
}


uint32_t FaceServ_getStatisTask_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            (*(this->success)).resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += (*(this->success))[_i103].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_addStatisTask_args::~FaceServ_addStatisTask_args() throw() {
}


uint32_t FaceServ_addStatisTask_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_camera_id);
          this->__isset.start_camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_camera_id);
          this->__isset.end_camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_addStatisTask_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_addStatisTask_args");

  xfer += oprot->writeFieldBegin("start_camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start_camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_addStatisTask_pargs::~FaceServ_addStatisTask_pargs() throw() {
}


uint32_t FaceServ_addStatisTask_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_addStatisTask_pargs");

  xfer += oprot->writeFieldBegin("start_camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->start_camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->end_camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_addStatisTask_result::~FaceServ_addStatisTask_result() throw() {
}


uint32_t FaceServ_addStatisTask_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_addStatisTask_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_addStatisTask_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_addStatisTask_presult::~FaceServ_addStatisTask_presult() throw() {
}


uint32_t FaceServ_addStatisTask_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_deleteStatisTask_args::~FaceServ_deleteStatisTask_args() throw() {
}


uint32_t FaceServ_deleteStatisTask_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->start_camera_id);
          this->__isset.start_camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->end_camera_id);
          this->__isset.end_camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_deleteStatisTask_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_deleteStatisTask_args");

  xfer += oprot->writeFieldBegin("start_camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->start_camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->end_camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_deleteStatisTask_pargs::~FaceServ_deleteStatisTask_pargs() throw() {
}


uint32_t FaceServ_deleteStatisTask_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_deleteStatisTask_pargs");

  xfer += oprot->writeFieldBegin("start_camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->start_camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_camera_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString((*(this->end_camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_deleteStatisTask_result::~FaceServ_deleteStatisTask_result() throw() {
}


uint32_t FaceServ_deleteStatisTask_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_deleteStatisTask_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_deleteStatisTask_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_deleteStatisTask_presult::~FaceServ_deleteStatisTask_presult() throw() {
}


uint32_t FaceServ_deleteStatisTask_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_getAlarmArea_args::~FaceServ_getAlarmArea_args() throw() {
}


uint32_t FaceServ_getAlarmArea_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getAlarmArea_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getAlarmArea_args");

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAlarmArea_pargs::~FaceServ_getAlarmArea_pargs() throw() {
}


uint32_t FaceServ_getAlarmArea_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_getAlarmArea_pargs");

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAlarmArea_result::~FaceServ_getAlarmArea_result() throw() {
}


uint32_t FaceServ_getAlarmArea_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_getAlarmArea_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_getAlarmArea_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_getAlarmArea_presult::~FaceServ_getAlarmArea_presult() throw() {
}


uint32_t FaceServ_getAlarmArea_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_setAlarmArea_args::~FaceServ_setAlarmArea_args() throw() {
}


uint32_t FaceServ_setAlarmArea_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->area_type = (AreaType::type)ecast104;
          this->__isset.area_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->area.clear();
            uint32_t _size105;
            ::apache::thrift::protocol::TType _etype108;
            xfer += iprot->readListBegin(_etype108, _size105);
            this->area.resize(_size105);
            uint32_t _i109;
            for (_i109 = 0; _i109 < _size105; ++_i109)
            {
              xfer += this->area[_i109].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.area = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_setAlarmArea_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_setAlarmArea_args");

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("area_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->area_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("area", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->area.size()));
    std::vector<Point> ::const_iterator _iter110;
    for (_iter110 = this->area.begin(); _iter110 != this->area.end(); ++_iter110)
    {
      xfer += (*_iter110).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_setAlarmArea_pargs::~FaceServ_setAlarmArea_pargs() throw() {
}


uint32_t FaceServ_setAlarmArea_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_setAlarmArea_pargs");

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("area_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->area_type)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("area", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->area)).size()));
    std::vector<Point> ::const_iterator _iter111;
    for (_iter111 = (*(this->area)).begin(); _iter111 != (*(this->area)).end(); ++_iter111)
    {
      xfer += (*_iter111).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_setAlarmArea_result::~FaceServ_setAlarmArea_result() throw() {
}


uint32_t FaceServ_setAlarmArea_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_setAlarmArea_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_setAlarmArea_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_setAlarmArea_presult::~FaceServ_setAlarmArea_presult() throw() {
}


uint32_t FaceServ_setAlarmArea_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_searchSnap_args::~FaceServ_searchSnap_args() throw() {
}


uint32_t FaceServ_searchSnap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->face_img);
          this->__isset.face_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->topk);
          this->__isset.topk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->thresh);
          this->__isset.thresh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_timestap);
          this->__isset.start_timestap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_timstap);
          this->__isset.end_timstap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_searchSnap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_searchSnap_args");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->face_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topk", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->topk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thresh", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->thresh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->start_timestap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->end_timstap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_searchSnap_pargs::~FaceServ_searchSnap_pargs() throw() {
}


uint32_t FaceServ_searchSnap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_searchSnap_pargs");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->face_img)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topk", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->topk)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thresh", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble((*(this->thresh)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64((*(this->start_timestap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64((*(this->end_timstap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_searchSnap_result::~FaceServ_searchSnap_result() throw() {
}


uint32_t FaceServ_searchSnap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->success.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += this->success[_i116].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_searchSnap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_searchSnap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<SearchFace> ::const_iterator _iter117;
      for (_iter117 = this->success.begin(); _iter117 != this->success.end(); ++_iter117)
      {
        xfer += (*_iter117).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_searchSnap_presult::~FaceServ_searchSnap_presult() throw() {
}


uint32_t FaceServ_searchSnap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            (*(this->success)).resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += (*(this->success))[_i122].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_pagenateSearchFaceSnap_args::~FaceServ_pagenateSearchFaceSnap_args() throw() {
}


uint32_t FaceServ_pagenateSearchFaceSnap_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->page);
          this->__isset.page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->face_img);
          this->__isset.face_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->camera_id);
          this->__isset.camera_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->topk);
          this->__isset.topk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->thresh);
          this->__isset.thresh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_timestap);
          this->__isset.start_timestap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_timstap);
          this->__isset.end_timstap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_pagenateSearchFaceSnap_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_pagenateSearchFaceSnap_args");

  xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->page);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->face_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->camera_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topk", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->topk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thresh", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->thresh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->start_timestap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->end_timstap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateSearchFaceSnap_pargs::~FaceServ_pagenateSearchFaceSnap_pargs() throw() {
}


uint32_t FaceServ_pagenateSearchFaceSnap_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_pagenateSearchFaceSnap_pargs");

  xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->page)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->num)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString((*(this->oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary((*(this->face_img)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("camera_id", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString((*(this->camera_id)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topk", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((*(this->topk)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thresh", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble((*(this->thresh)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64((*(this->start_timestap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64((*(this->end_timstap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateSearchFaceSnap_result::~FaceServ_pagenateSearchFaceSnap_result() throw() {
}


uint32_t FaceServ_pagenateSearchFaceSnap_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_pagenateSearchFaceSnap_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_pagenateSearchFaceSnap_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_pagenateSearchFaceSnap_presult::~FaceServ_pagenateSearchFaceSnap_presult() throw() {
}


uint32_t FaceServ_pagenateSearchFaceSnap_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_gnerateFaceTrace_args::~FaceServ_gnerateFaceTrace_args() throw() {
}


uint32_t FaceServ_gnerateFaceTrace_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->face_img);
          this->__isset.face_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->thresh);
          this->__isset.thresh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_timestap);
          this->__isset.start_timestap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_timstap);
          this->__isset.end_timstap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_gnerateFaceTrace_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_gnerateFaceTrace_args");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->face_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thresh", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->thresh);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->start_timestap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->end_timstap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_gnerateFaceTrace_pargs::~FaceServ_gnerateFaceTrace_pargs() throw() {
}


uint32_t FaceServ_gnerateFaceTrace_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_gnerateFaceTrace_pargs");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->face_img)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thresh", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble((*(this->thresh)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->start_timestap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timstap", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64((*(this->end_timstap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_gnerateFaceTrace_result::~FaceServ_gnerateFaceTrace_result() throw() {
}


uint32_t FaceServ_gnerateFaceTrace_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size123;
            ::apache::thrift::protocol::TType _etype126;
            xfer += iprot->readListBegin(_etype126, _size123);
            this->success.resize(_size123);
            uint32_t _i127;
            for (_i127 = 0; _i127 < _size123; ++_i127)
            {
              xfer += this->success[_i127].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_gnerateFaceTrace_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_gnerateFaceTrace_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector<SearchFace> ::const_iterator _iter128;
      for (_iter128 = this->success.begin(); _iter128 != this->success.end(); ++_iter128)
      {
        xfer += (*_iter128).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_gnerateFaceTrace_presult::~FaceServ_gnerateFaceTrace_presult() throw() {
}


uint32_t FaceServ_gnerateFaceTrace_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _etype132;
            xfer += iprot->readListBegin(_etype132, _size129);
            (*(this->success)).resize(_size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              xfer += (*(this->success))[_i133].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


FaceServ_generateFaceLink_args::~FaceServ_generateFaceLink_args() throw() {
}


uint32_t FaceServ_generateFaceLink_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->oid);
          this->__isset.oid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->face_img);
          this->__isset.face_img = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->start_timestap);
          this->__isset.start_timestap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->end_timestap);
          this->__isset.end_timestap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_generateFaceLink_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_generateFaceLink_args");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->oid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->face_img);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->start_timestap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timestap", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->end_timestap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_generateFaceLink_pargs::~FaceServ_generateFaceLink_pargs() throw() {
}


uint32_t FaceServ_generateFaceLink_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FaceServ_generateFaceLink_pargs");

  xfer += oprot->writeFieldBegin("oid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->oid)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("face_img", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->face_img)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start_timestap", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64((*(this->start_timestap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("end_timestap", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64((*(this->end_timestap)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_generateFaceLink_result::~FaceServ_generateFaceLink_result() throw() {
}


uint32_t FaceServ_generateFaceLink_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FaceServ_generateFaceLink_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("FaceServ_generateFaceLink_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


FaceServ_generateFaceLink_presult::~FaceServ_generateFaceLink_presult() throw() {
}


uint32_t FaceServ_generateFaceLink_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void FaceServClient::getFacePic(std::string& _return, const std::string& oid)
{
  send_getFacePic(oid);
  recv_getFacePic(_return);
}

void FaceServClient::send_getFacePic(const std::string& oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getFacePic", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getFacePic_pargs args;
  args.oid = &oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_getFacePic(std::string& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getFacePic") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_getFacePic_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getFacePic failed: unknown result");
}

void FaceServClient::getScenePic(ScenePic& _return, const std::string& oid)
{
  send_getScenePic(oid);
  recv_getScenePic(_return);
}

void FaceServClient::send_getScenePic(const std::string& oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getScenePic", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getScenePic_pargs args;
  args.oid = &oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_getScenePic(ScenePic& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getScenePic") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_getScenePic_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getScenePic failed: unknown result");
}

void FaceServClient::getAlarmScenePic(ScenePic& _return, const std::string& oid)
{
  send_getAlarmScenePic(oid);
  recv_getAlarmScenePic(_return);
}

void FaceServClient::send_getAlarmScenePic(const std::string& oid)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getAlarmScenePic", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getAlarmScenePic_pargs args;
  args.oid = &oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_getAlarmScenePic(ScenePic& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getAlarmScenePic") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_getAlarmScenePic_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAlarmScenePic failed: unknown result");
}

void FaceServClient::getAllCameraInfo(std::vector<CameraInfo> & _return)
{
  send_getAllCameraInfo();
  recv_getAllCameraInfo(_return);
}

void FaceServClient::send_getAllCameraInfo()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getAllCameraInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getAllCameraInfo_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_getAllCameraInfo(std::vector<CameraInfo> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getAllCameraInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_getAllCameraInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAllCameraInfo failed: unknown result");
}

void FaceServClient::snapHistory(std::vector<SnapFaceHis> & _return, const std::string& cameraid, const int64_t start_timestap, const int64_t end_timstap)
{
  send_snapHistory(cameraid, start_timestap, end_timstap);
  recv_snapHistory(_return);
}

void FaceServClient::send_snapHistory(const std::string& cameraid, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("snapHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_snapHistory_pargs args;
  args.cameraid = &cameraid;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_snapHistory(std::vector<SnapFaceHis> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("snapHistory") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_snapHistory_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "snapHistory failed: unknown result");
}

void FaceServClient::pagenateSnapHistory(PagedSnapFaceHis& _return, const int32_t page, const int32_t num, const std::string& cameraid, const int64_t start_timestap, const int64_t end_timstap)
{
  send_pagenateSnapHistory(page, num, cameraid, start_timestap, end_timstap);
  recv_pagenateSnapHistory(_return);
}

void FaceServClient::send_pagenateSnapHistory(const int32_t page, const int32_t num, const std::string& cameraid, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("pagenateSnapHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_pagenateSnapHistory_pargs args;
  args.page = &page;
  args.num = &num;
  args.cameraid = &cameraid;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_pagenateSnapHistory(PagedSnapFaceHis& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("pagenateSnapHistory") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_pagenateSnapHistory_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "pagenateSnapHistory failed: unknown result");
}

void FaceServClient::pagenateAlarmHistory(PagedAlarmHis& _return, const int32_t page, const int32_t num, const std::string& camera_id, const std::string& alarm_type, const int64_t start_timestap, const int64_t end_timstap)
{
  send_pagenateAlarmHistory(page, num, camera_id, alarm_type, start_timestap, end_timstap);
  recv_pagenateAlarmHistory(_return);
}

void FaceServClient::send_pagenateAlarmHistory(const int32_t page, const int32_t num, const std::string& camera_id, const std::string& alarm_type, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("pagenateAlarmHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_pagenateAlarmHistory_pargs args;
  args.page = &page;
  args.num = &num;
  args.camera_id = &camera_id;
  args.alarm_type = &alarm_type;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_pagenateAlarmHistory(PagedAlarmHis& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("pagenateAlarmHistory") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_pagenateAlarmHistory_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "pagenateAlarmHistory failed: unknown result");
}

void FaceServClient::getStatisTask(std::vector<StatisTask> & _return)
{
  send_getStatisTask();
  recv_getStatisTask(_return);
}

void FaceServClient::send_getStatisTask()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getStatisTask", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getStatisTask_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_getStatisTask(std::vector<StatisTask> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getStatisTask") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_getStatisTask_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getStatisTask failed: unknown result");
}

bool FaceServClient::addStatisTask(const std::string& start_camera_id, const std::string& end_camera_id)
{
  send_addStatisTask(start_camera_id, end_camera_id);
  return recv_addStatisTask();
}

void FaceServClient::send_addStatisTask(const std::string& start_camera_id, const std::string& end_camera_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("addStatisTask", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_addStatisTask_pargs args;
  args.start_camera_id = &start_camera_id;
  args.end_camera_id = &end_camera_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool FaceServClient::recv_addStatisTask()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("addStatisTask") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  FaceServ_addStatisTask_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "addStatisTask failed: unknown result");
}

bool FaceServClient::deleteStatisTask(const std::string& start_camera_id, const std::string& end_camera_id)
{
  send_deleteStatisTask(start_camera_id, end_camera_id);
  return recv_deleteStatisTask();
}

void FaceServClient::send_deleteStatisTask(const std::string& start_camera_id, const std::string& end_camera_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("deleteStatisTask", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_deleteStatisTask_pargs args;
  args.start_camera_id = &start_camera_id;
  args.end_camera_id = &end_camera_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool FaceServClient::recv_deleteStatisTask()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("deleteStatisTask") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  FaceServ_deleteStatisTask_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteStatisTask failed: unknown result");
}

void FaceServClient::getAlarmArea(Area& _return, const std::string& camera_id)
{
  send_getAlarmArea(camera_id);
  recv_getAlarmArea(_return);
}

void FaceServClient::send_getAlarmArea(const std::string& camera_id)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getAlarmArea", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getAlarmArea_pargs args;
  args.camera_id = &camera_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_getAlarmArea(Area& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getAlarmArea") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_getAlarmArea_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAlarmArea failed: unknown result");
}

bool FaceServClient::setAlarmArea(const std::string& camera_id, const AreaType::type area_type, const std::vector<Point> & area)
{
  send_setAlarmArea(camera_id, area_type, area);
  return recv_setAlarmArea();
}

void FaceServClient::send_setAlarmArea(const std::string& camera_id, const AreaType::type area_type, const std::vector<Point> & area)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("setAlarmArea", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_setAlarmArea_pargs args;
  args.camera_id = &camera_id;
  args.area_type = &area_type;
  args.area = &area;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool FaceServClient::recv_setAlarmArea()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("setAlarmArea") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  FaceServ_setAlarmArea_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setAlarmArea failed: unknown result");
}

void FaceServClient::searchSnap(std::vector<SearchFace> & _return, const std::string& oid, const std::string& face_img, const std::string& camera_id, const int32_t topk, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  send_searchSnap(oid, face_img, camera_id, topk, thresh, start_timestap, end_timstap);
  recv_searchSnap(_return);
}

void FaceServClient::send_searchSnap(const std::string& oid, const std::string& face_img, const std::string& camera_id, const int32_t topk, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("searchSnap", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_searchSnap_pargs args;
  args.oid = &oid;
  args.face_img = &face_img;
  args.camera_id = &camera_id;
  args.topk = &topk;
  args.thresh = &thresh;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_searchSnap(std::vector<SearchFace> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("searchSnap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_searchSnap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "searchSnap failed: unknown result");
}

void FaceServClient::pagenateSearchFaceSnap(PageSnapFaceHis& _return, const int32_t page, const int32_t num, const std::string& oid, const std::string& face_img, const std::string& camera_id, const int32_t topk, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  send_pagenateSearchFaceSnap(page, num, oid, face_img, camera_id, topk, thresh, start_timestap, end_timstap);
  recv_pagenateSearchFaceSnap(_return);
}

void FaceServClient::send_pagenateSearchFaceSnap(const int32_t page, const int32_t num, const std::string& oid, const std::string& face_img, const std::string& camera_id, const int32_t topk, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("pagenateSearchFaceSnap", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_pagenateSearchFaceSnap_pargs args;
  args.page = &page;
  args.num = &num;
  args.oid = &oid;
  args.face_img = &face_img;
  args.camera_id = &camera_id;
  args.topk = &topk;
  args.thresh = &thresh;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_pagenateSearchFaceSnap(PageSnapFaceHis& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("pagenateSearchFaceSnap") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_pagenateSearchFaceSnap_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "pagenateSearchFaceSnap failed: unknown result");
}

void FaceServClient::gnerateFaceTrace(std::vector<SearchFace> & _return, const std::string& oid, const std::string& face_img, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  send_gnerateFaceTrace(oid, face_img, thresh, start_timestap, end_timstap);
  recv_gnerateFaceTrace(_return);
}

void FaceServClient::send_gnerateFaceTrace(const std::string& oid, const std::string& face_img, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("gnerateFaceTrace", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_gnerateFaceTrace_pargs args;
  args.oid = &oid;
  args.face_img = &face_img;
  args.thresh = &thresh;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_gnerateFaceTrace(std::vector<SearchFace> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("gnerateFaceTrace") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_gnerateFaceTrace_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "gnerateFaceTrace failed: unknown result");
}

void FaceServClient::generateFaceLink(FaceLink& _return, const std::string& oid, const std::string& face_img, const int64_t start_timestap, const int64_t end_timestap)
{
  send_generateFaceLink(oid, face_img, start_timestap, end_timestap);
  recv_generateFaceLink(_return);
}

void FaceServClient::send_generateFaceLink(const std::string& oid, const std::string& face_img, const int64_t start_timestap, const int64_t end_timestap)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("generateFaceLink", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_generateFaceLink_pargs args;
  args.oid = &oid;
  args.face_img = &face_img;
  args.start_timestap = &start_timestap;
  args.end_timestap = &end_timestap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void FaceServClient::recv_generateFaceLink(FaceLink& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("generateFaceLink") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  FaceServ_generateFaceLink_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "generateFaceLink failed: unknown result");
}

bool FaceServProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void FaceServProcessor::process_getFacePic(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.getFacePic", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.getFacePic");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.getFacePic");
  }

  FaceServ_getFacePic_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.getFacePic", bytes);
  }

  FaceServ_getFacePic_result result;
  try {
    iface_->getFacePic(result.success, args.oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.getFacePic");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getFacePic", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.getFacePic");
  }

  oprot->writeMessageBegin("getFacePic", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.getFacePic", bytes);
  }
}

void FaceServProcessor::process_getScenePic(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.getScenePic", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.getScenePic");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.getScenePic");
  }

  FaceServ_getScenePic_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.getScenePic", bytes);
  }

  FaceServ_getScenePic_result result;
  try {
    iface_->getScenePic(result.success, args.oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.getScenePic");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getScenePic", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.getScenePic");
  }

  oprot->writeMessageBegin("getScenePic", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.getScenePic", bytes);
  }
}

void FaceServProcessor::process_getAlarmScenePic(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.getAlarmScenePic", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.getAlarmScenePic");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.getAlarmScenePic");
  }

  FaceServ_getAlarmScenePic_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.getAlarmScenePic", bytes);
  }

  FaceServ_getAlarmScenePic_result result;
  try {
    iface_->getAlarmScenePic(result.success, args.oid);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.getAlarmScenePic");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getAlarmScenePic", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.getAlarmScenePic");
  }

  oprot->writeMessageBegin("getAlarmScenePic", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.getAlarmScenePic", bytes);
  }
}

void FaceServProcessor::process_getAllCameraInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.getAllCameraInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.getAllCameraInfo");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.getAllCameraInfo");
  }

  FaceServ_getAllCameraInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.getAllCameraInfo", bytes);
  }

  FaceServ_getAllCameraInfo_result result;
  try {
    iface_->getAllCameraInfo(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.getAllCameraInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getAllCameraInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.getAllCameraInfo");
  }

  oprot->writeMessageBegin("getAllCameraInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.getAllCameraInfo", bytes);
  }
}

void FaceServProcessor::process_snapHistory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.snapHistory", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.snapHistory");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.snapHistory");
  }

  FaceServ_snapHistory_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.snapHistory", bytes);
  }

  FaceServ_snapHistory_result result;
  try {
    iface_->snapHistory(result.success, args.cameraid, args.start_timestap, args.end_timstap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.snapHistory");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("snapHistory", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.snapHistory");
  }

  oprot->writeMessageBegin("snapHistory", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.snapHistory", bytes);
  }
}

void FaceServProcessor::process_pagenateSnapHistory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.pagenateSnapHistory", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.pagenateSnapHistory");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.pagenateSnapHistory");
  }

  FaceServ_pagenateSnapHistory_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.pagenateSnapHistory", bytes);
  }

  FaceServ_pagenateSnapHistory_result result;
  try {
    iface_->pagenateSnapHistory(result.success, args.page, args.num, args.cameraid, args.start_timestap, args.end_timstap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.pagenateSnapHistory");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("pagenateSnapHistory", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.pagenateSnapHistory");
  }

  oprot->writeMessageBegin("pagenateSnapHistory", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.pagenateSnapHistory", bytes);
  }
}

void FaceServProcessor::process_pagenateAlarmHistory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.pagenateAlarmHistory", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.pagenateAlarmHistory");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.pagenateAlarmHistory");
  }

  FaceServ_pagenateAlarmHistory_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.pagenateAlarmHistory", bytes);
  }

  FaceServ_pagenateAlarmHistory_result result;
  try {
    iface_->pagenateAlarmHistory(result.success, args.page, args.num, args.camera_id, args.alarm_type, args.start_timestap, args.end_timstap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.pagenateAlarmHistory");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("pagenateAlarmHistory", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.pagenateAlarmHistory");
  }

  oprot->writeMessageBegin("pagenateAlarmHistory", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.pagenateAlarmHistory", bytes);
  }
}

void FaceServProcessor::process_getStatisTask(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.getStatisTask", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.getStatisTask");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.getStatisTask");
  }

  FaceServ_getStatisTask_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.getStatisTask", bytes);
  }

  FaceServ_getStatisTask_result result;
  try {
    iface_->getStatisTask(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.getStatisTask");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getStatisTask", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.getStatisTask");
  }

  oprot->writeMessageBegin("getStatisTask", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.getStatisTask", bytes);
  }
}

void FaceServProcessor::process_addStatisTask(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.addStatisTask", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.addStatisTask");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.addStatisTask");
  }

  FaceServ_addStatisTask_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.addStatisTask", bytes);
  }

  FaceServ_addStatisTask_result result;
  try {
    result.success = iface_->addStatisTask(args.start_camera_id, args.end_camera_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.addStatisTask");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("addStatisTask", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.addStatisTask");
  }

  oprot->writeMessageBegin("addStatisTask", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.addStatisTask", bytes);
  }
}

void FaceServProcessor::process_deleteStatisTask(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.deleteStatisTask", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.deleteStatisTask");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.deleteStatisTask");
  }

  FaceServ_deleteStatisTask_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.deleteStatisTask", bytes);
  }

  FaceServ_deleteStatisTask_result result;
  try {
    result.success = iface_->deleteStatisTask(args.start_camera_id, args.end_camera_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.deleteStatisTask");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("deleteStatisTask", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.deleteStatisTask");
  }

  oprot->writeMessageBegin("deleteStatisTask", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.deleteStatisTask", bytes);
  }
}

void FaceServProcessor::process_getAlarmArea(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.getAlarmArea", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.getAlarmArea");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.getAlarmArea");
  }

  FaceServ_getAlarmArea_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.getAlarmArea", bytes);
  }

  FaceServ_getAlarmArea_result result;
  try {
    iface_->getAlarmArea(result.success, args.camera_id);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.getAlarmArea");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getAlarmArea", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.getAlarmArea");
  }

  oprot->writeMessageBegin("getAlarmArea", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.getAlarmArea", bytes);
  }
}

void FaceServProcessor::process_setAlarmArea(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.setAlarmArea", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.setAlarmArea");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.setAlarmArea");
  }

  FaceServ_setAlarmArea_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.setAlarmArea", bytes);
  }

  FaceServ_setAlarmArea_result result;
  try {
    result.success = iface_->setAlarmArea(args.camera_id, args.area_type, args.area);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.setAlarmArea");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("setAlarmArea", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.setAlarmArea");
  }

  oprot->writeMessageBegin("setAlarmArea", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.setAlarmArea", bytes);
  }
}

void FaceServProcessor::process_searchSnap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.searchSnap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.searchSnap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.searchSnap");
  }

  FaceServ_searchSnap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.searchSnap", bytes);
  }

  FaceServ_searchSnap_result result;
  try {
    iface_->searchSnap(result.success, args.oid, args.face_img, args.camera_id, args.topk, args.thresh, args.start_timestap, args.end_timstap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.searchSnap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("searchSnap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.searchSnap");
  }

  oprot->writeMessageBegin("searchSnap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.searchSnap", bytes);
  }
}

void FaceServProcessor::process_pagenateSearchFaceSnap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.pagenateSearchFaceSnap", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.pagenateSearchFaceSnap");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.pagenateSearchFaceSnap");
  }

  FaceServ_pagenateSearchFaceSnap_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.pagenateSearchFaceSnap", bytes);
  }

  FaceServ_pagenateSearchFaceSnap_result result;
  try {
    iface_->pagenateSearchFaceSnap(result.success, args.page, args.num, args.oid, args.face_img, args.camera_id, args.topk, args.thresh, args.start_timestap, args.end_timstap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.pagenateSearchFaceSnap");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("pagenateSearchFaceSnap", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.pagenateSearchFaceSnap");
  }

  oprot->writeMessageBegin("pagenateSearchFaceSnap", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.pagenateSearchFaceSnap", bytes);
  }
}

void FaceServProcessor::process_gnerateFaceTrace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.gnerateFaceTrace", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.gnerateFaceTrace");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.gnerateFaceTrace");
  }

  FaceServ_gnerateFaceTrace_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.gnerateFaceTrace", bytes);
  }

  FaceServ_gnerateFaceTrace_result result;
  try {
    iface_->gnerateFaceTrace(result.success, args.oid, args.face_img, args.thresh, args.start_timestap, args.end_timstap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.gnerateFaceTrace");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("gnerateFaceTrace", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.gnerateFaceTrace");
  }

  oprot->writeMessageBegin("gnerateFaceTrace", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.gnerateFaceTrace", bytes);
  }
}

void FaceServProcessor::process_generateFaceLink(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("FaceServ.generateFaceLink", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "FaceServ.generateFaceLink");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "FaceServ.generateFaceLink");
  }

  FaceServ_generateFaceLink_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "FaceServ.generateFaceLink", bytes);
  }

  FaceServ_generateFaceLink_result result;
  try {
    iface_->generateFaceLink(result.success, args.oid, args.face_img, args.start_timestap, args.end_timestap);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "FaceServ.generateFaceLink");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("generateFaceLink", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "FaceServ.generateFaceLink");
  }

  oprot->writeMessageBegin("generateFaceLink", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "FaceServ.generateFaceLink", bytes);
  }
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > FaceServProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< FaceServIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< FaceServIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > processor(new FaceServProcessor(handler));
  return processor;
}

void FaceServConcurrentClient::getFacePic(std::string& _return, const std::string& oid)
{
  int32_t seqid = send_getFacePic(oid);
  recv_getFacePic(_return, seqid);
}

int32_t FaceServConcurrentClient::send_getFacePic(const std::string& oid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getFacePic", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getFacePic_pargs args;
  args.oid = &oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_getFacePic(std::string& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getFacePic") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_getFacePic_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getFacePic failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::getScenePic(ScenePic& _return, const std::string& oid)
{
  int32_t seqid = send_getScenePic(oid);
  recv_getScenePic(_return, seqid);
}

int32_t FaceServConcurrentClient::send_getScenePic(const std::string& oid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getScenePic", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getScenePic_pargs args;
  args.oid = &oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_getScenePic(ScenePic& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getScenePic") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_getScenePic_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getScenePic failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::getAlarmScenePic(ScenePic& _return, const std::string& oid)
{
  int32_t seqid = send_getAlarmScenePic(oid);
  recv_getAlarmScenePic(_return, seqid);
}

int32_t FaceServConcurrentClient::send_getAlarmScenePic(const std::string& oid)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getAlarmScenePic", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getAlarmScenePic_pargs args;
  args.oid = &oid;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_getAlarmScenePic(ScenePic& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getAlarmScenePic") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_getAlarmScenePic_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAlarmScenePic failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::getAllCameraInfo(std::vector<CameraInfo> & _return)
{
  int32_t seqid = send_getAllCameraInfo();
  recv_getAllCameraInfo(_return, seqid);
}

int32_t FaceServConcurrentClient::send_getAllCameraInfo()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getAllCameraInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getAllCameraInfo_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_getAllCameraInfo(std::vector<CameraInfo> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getAllCameraInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_getAllCameraInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAllCameraInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::snapHistory(std::vector<SnapFaceHis> & _return, const std::string& cameraid, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t seqid = send_snapHistory(cameraid, start_timestap, end_timstap);
  recv_snapHistory(_return, seqid);
}

int32_t FaceServConcurrentClient::send_snapHistory(const std::string& cameraid, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("snapHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_snapHistory_pargs args;
  args.cameraid = &cameraid;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_snapHistory(std::vector<SnapFaceHis> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("snapHistory") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_snapHistory_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "snapHistory failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::pagenateSnapHistory(PagedSnapFaceHis& _return, const int32_t page, const int32_t num, const std::string& cameraid, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t seqid = send_pagenateSnapHistory(page, num, cameraid, start_timestap, end_timstap);
  recv_pagenateSnapHistory(_return, seqid);
}

int32_t FaceServConcurrentClient::send_pagenateSnapHistory(const int32_t page, const int32_t num, const std::string& cameraid, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("pagenateSnapHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_pagenateSnapHistory_pargs args;
  args.page = &page;
  args.num = &num;
  args.cameraid = &cameraid;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_pagenateSnapHistory(PagedSnapFaceHis& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("pagenateSnapHistory") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_pagenateSnapHistory_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "pagenateSnapHistory failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::pagenateAlarmHistory(PagedAlarmHis& _return, const int32_t page, const int32_t num, const std::string& camera_id, const std::string& alarm_type, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t seqid = send_pagenateAlarmHistory(page, num, camera_id, alarm_type, start_timestap, end_timstap);
  recv_pagenateAlarmHistory(_return, seqid);
}

int32_t FaceServConcurrentClient::send_pagenateAlarmHistory(const int32_t page, const int32_t num, const std::string& camera_id, const std::string& alarm_type, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("pagenateAlarmHistory", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_pagenateAlarmHistory_pargs args;
  args.page = &page;
  args.num = &num;
  args.camera_id = &camera_id;
  args.alarm_type = &alarm_type;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_pagenateAlarmHistory(PagedAlarmHis& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("pagenateAlarmHistory") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_pagenateAlarmHistory_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "pagenateAlarmHistory failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::getStatisTask(std::vector<StatisTask> & _return)
{
  int32_t seqid = send_getStatisTask();
  recv_getStatisTask(_return, seqid);
}

int32_t FaceServConcurrentClient::send_getStatisTask()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getStatisTask", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getStatisTask_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_getStatisTask(std::vector<StatisTask> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getStatisTask") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_getStatisTask_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getStatisTask failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool FaceServConcurrentClient::addStatisTask(const std::string& start_camera_id, const std::string& end_camera_id)
{
  int32_t seqid = send_addStatisTask(start_camera_id, end_camera_id);
  return recv_addStatisTask(seqid);
}

int32_t FaceServConcurrentClient::send_addStatisTask(const std::string& start_camera_id, const std::string& end_camera_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("addStatisTask", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_addStatisTask_pargs args;
  args.start_camera_id = &start_camera_id;
  args.end_camera_id = &end_camera_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool FaceServConcurrentClient::recv_addStatisTask(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("addStatisTask") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      FaceServ_addStatisTask_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "addStatisTask failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool FaceServConcurrentClient::deleteStatisTask(const std::string& start_camera_id, const std::string& end_camera_id)
{
  int32_t seqid = send_deleteStatisTask(start_camera_id, end_camera_id);
  return recv_deleteStatisTask(seqid);
}

int32_t FaceServConcurrentClient::send_deleteStatisTask(const std::string& start_camera_id, const std::string& end_camera_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("deleteStatisTask", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_deleteStatisTask_pargs args;
  args.start_camera_id = &start_camera_id;
  args.end_camera_id = &end_camera_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool FaceServConcurrentClient::recv_deleteStatisTask(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("deleteStatisTask") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      FaceServ_deleteStatisTask_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "deleteStatisTask failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::getAlarmArea(Area& _return, const std::string& camera_id)
{
  int32_t seqid = send_getAlarmArea(camera_id);
  recv_getAlarmArea(_return, seqid);
}

int32_t FaceServConcurrentClient::send_getAlarmArea(const std::string& camera_id)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("getAlarmArea", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_getAlarmArea_pargs args;
  args.camera_id = &camera_id;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_getAlarmArea(Area& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getAlarmArea") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_getAlarmArea_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getAlarmArea failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

bool FaceServConcurrentClient::setAlarmArea(const std::string& camera_id, const AreaType::type area_type, const std::vector<Point> & area)
{
  int32_t seqid = send_setAlarmArea(camera_id, area_type, area);
  return recv_setAlarmArea(seqid);
}

int32_t FaceServConcurrentClient::send_setAlarmArea(const std::string& camera_id, const AreaType::type area_type, const std::vector<Point> & area)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("setAlarmArea", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_setAlarmArea_pargs args;
  args.camera_id = &camera_id;
  args.area_type = &area_type;
  args.area = &area;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool FaceServConcurrentClient::recv_setAlarmArea(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("setAlarmArea") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      FaceServ_setAlarmArea_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "setAlarmArea failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::searchSnap(std::vector<SearchFace> & _return, const std::string& oid, const std::string& face_img, const std::string& camera_id, const int32_t topk, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t seqid = send_searchSnap(oid, face_img, camera_id, topk, thresh, start_timestap, end_timstap);
  recv_searchSnap(_return, seqid);
}

int32_t FaceServConcurrentClient::send_searchSnap(const std::string& oid, const std::string& face_img, const std::string& camera_id, const int32_t topk, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("searchSnap", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_searchSnap_pargs args;
  args.oid = &oid;
  args.face_img = &face_img;
  args.camera_id = &camera_id;
  args.topk = &topk;
  args.thresh = &thresh;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_searchSnap(std::vector<SearchFace> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("searchSnap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_searchSnap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "searchSnap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::pagenateSearchFaceSnap(PageSnapFaceHis& _return, const int32_t page, const int32_t num, const std::string& oid, const std::string& face_img, const std::string& camera_id, const int32_t topk, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t seqid = send_pagenateSearchFaceSnap(page, num, oid, face_img, camera_id, topk, thresh, start_timestap, end_timstap);
  recv_pagenateSearchFaceSnap(_return, seqid);
}

int32_t FaceServConcurrentClient::send_pagenateSearchFaceSnap(const int32_t page, const int32_t num, const std::string& oid, const std::string& face_img, const std::string& camera_id, const int32_t topk, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("pagenateSearchFaceSnap", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_pagenateSearchFaceSnap_pargs args;
  args.page = &page;
  args.num = &num;
  args.oid = &oid;
  args.face_img = &face_img;
  args.camera_id = &camera_id;
  args.topk = &topk;
  args.thresh = &thresh;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_pagenateSearchFaceSnap(PageSnapFaceHis& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("pagenateSearchFaceSnap") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_pagenateSearchFaceSnap_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "pagenateSearchFaceSnap failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::gnerateFaceTrace(std::vector<SearchFace> & _return, const std::string& oid, const std::string& face_img, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t seqid = send_gnerateFaceTrace(oid, face_img, thresh, start_timestap, end_timstap);
  recv_gnerateFaceTrace(_return, seqid);
}

int32_t FaceServConcurrentClient::send_gnerateFaceTrace(const std::string& oid, const std::string& face_img, const double thresh, const int64_t start_timestap, const int64_t end_timstap)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("gnerateFaceTrace", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_gnerateFaceTrace_pargs args;
  args.oid = &oid;
  args.face_img = &face_img;
  args.thresh = &thresh;
  args.start_timestap = &start_timestap;
  args.end_timstap = &end_timstap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_gnerateFaceTrace(std::vector<SearchFace> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("gnerateFaceTrace") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_gnerateFaceTrace_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "gnerateFaceTrace failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void FaceServConcurrentClient::generateFaceLink(FaceLink& _return, const std::string& oid, const std::string& face_img, const int64_t start_timestap, const int64_t end_timestap)
{
  int32_t seqid = send_generateFaceLink(oid, face_img, start_timestap, end_timestap);
  recv_generateFaceLink(_return, seqid);
}

int32_t FaceServConcurrentClient::send_generateFaceLink(const std::string& oid, const std::string& face_img, const int64_t start_timestap, const int64_t end_timestap)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("generateFaceLink", ::apache::thrift::protocol::T_CALL, cseqid);

  FaceServ_generateFaceLink_pargs args;
  args.oid = &oid;
  args.face_img = &face_img;
  args.start_timestap = &start_timestap;
  args.end_timestap = &end_timestap;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void FaceServConcurrentClient::recv_generateFaceLink(FaceLink& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("generateFaceLink") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      FaceServ_generateFaceLink_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "generateFaceLink failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}



